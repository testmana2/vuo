/**
 * @file
 * VuoCompiler implementation.
 *
 * @copyright Copyright © 2012–2016 Kosada Incorporated.
 * This code may be modified and distributed under the terms of the GNU Lesser General Public License (LGPL) version 2 or later.
 * For more information, see http://vuo.org/license.
 */

#include <fcntl.h>
#include <string.h>
#include <sstream>
#include <locale>
#include "VuoCompiler.hh"
#include "VuoCompilerBitcodeGenerator.hh"
#include "VuoCompilerBitcodeParser.hh"
#include "VuoCompilerCodeGenUtilities.hh"
#include "VuoCompilerComposition.hh"
#include "VuoCompilerException.hh"
#include "VuoCompilerGenericType.hh"
#include "VuoCompilerMakeListNodeClass.hh"
#include "VuoCompilerNode.hh"
#include "VuoCompilerNodeClass.hh"
#include "VuoCompilerPort.hh"
#include "VuoCompilerPortClass.hh"
#include "VuoCompilerPublishedInputNodeClass.hh"
#include "VuoCompilerPublishedOutputNodeClass.hh"
#include "VuoCompilerSpecializedNodeClass.hh"
#include "VuoCompilerTriggerDescription.hh"
#include "VuoGenericType.hh"
#include "VuoNode.hh"
#include "VuoNodeSet.hh"
#include "VuoPort.hh"
#include "VuoPublishedPort.hh"
#include "VuoRunner.hh"
#include "VuoStringUtilities.hh"

#ifdef PREMIUM_NODE_LOADER_ENABLED
#define VUO_PREMIUM_INITIALIZER
#include "VuoPremium.hh"
#endif

bool VuoCompiler::isLlvmInitialized = false;
dispatch_queue_t VuoCompiler::llvmQueue = dispatch_queue_create("org.vuo.compiler.llvm", NULL);
dispatch_queue_t VuoCompiler::environmentQueue = dispatch_queue_create("org.vuo.compiler.environment", NULL);
dispatch_queue_t VuoCompiler::cachedResourcesQueue = dispatch_queue_create("org.vuo.compiler.cache", NULL);
dispatch_queue_t VuoCompiler::hasCleanedCompiledSubcompositionDirQueue = dispatch_queue_create("org.vuo.compiler.clean", NULL);
const int VuoCompiler::NUM_CACHES = 2;
bool VuoCompiler::hasTriedCachedResources[2] = { false, false };
string VuoCompiler::cachedResourceDylib[2];
set<string> VuoCompiler::cachedResources[2];
set<string> VuoCompiler::encounteredPremiumModules;
VuoCompiler::Environment * VuoCompiler::sharedEnvironment = NULL;
bool VuoCompiler::hasCleanedCompiledSubcompositionDir = false;

/**
 * Creates an empty environment.
 */
VuoCompiler::Environment::Environment(bool isOwner)
{
	this->isOwner = isOwner;
}

/**
 * Destructor.
 */
VuoCompiler::Environment::~Environment(void)
{
	if (! isOwner)
		return;

	set<Module *> modulesToDelete;

	for (map<string, VuoCompilerNodeClass *>::iterator i = nodeClasses.begin(); i != nodeClasses.end(); ++i)
	{
		modulesToDelete.insert( i->second->getModule() );
		VuoNodeClass *base = i->second->getBase();
		delete i->second;
		delete base;
	}
	for (map<string, VuoCompilerType *>::iterator i = types.begin(); i != types.end(); ++i)
	{
		modulesToDelete.insert( i->second->getModule() );
		VuoType *base = i->second->getBase();
		delete i->second;
		delete base;
	}
	for (set<VuoCompilerGenericType *>::iterator i = genericTypes.begin(); i != genericTypes.end(); ++i)
	{
		VuoType *base = (*i)->getBase();
		delete *i;
		delete base;
	}
	for (map<string, VuoCompilerModule *>::iterator i = libraryModules.begin(); i != libraryModules.end(); ++i)
	{
		modulesToDelete.insert( i->second->getModule() );
		VuoModule *base = i->second->getPseudoBase();
		delete i->second;
		delete base;
	}

	for (set<Module *>::iterator i = modulesToDelete.begin(); i != modulesToDelete.end(); ++i)
		deleteModule(*i);

	for (map<string, VuoNodeSet *>::iterator i = nodeSetForName.begin(); i != nodeSetForName.end(); ++i)
		delete i->second;

	for (map<string, map<string, VuoFileUtilities::File *> >::iterator i = moduleFilesAtSearchPath.begin(); i != moduleFilesAtSearchPath.end(); ++i)
		for (map<string, VuoFileUtilities::File *>::iterator j = i->second.begin(); j != i->second.end(); ++j)
			delete j->second;
}

/**
 * Returns the node classes loaded, plus specialized node classes generated by the compiler.
 */
map<string, VuoCompilerNodeClass *> VuoCompiler::Environment::getNodeClasses(void)
{
	__block map<string, VuoCompilerNodeClass *> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = nodeClasses;
				  });
	return ret;
}

/**
 * Returns the node class with the given @a moduleKey, or null if no node class by that name has been loaded.
 */
VuoCompilerNodeClass * VuoCompiler::Environment::getNodeClass(const string &moduleKey)
{
	__block VuoCompilerNodeClass *nodeClass = NULL;
	dispatch_sync(environmentQueue, ^{
					  map<string, VuoCompilerNodeClass *>::iterator nodeClassIter = nodeClasses.find(moduleKey);
					  if (nodeClassIter != nodeClasses.end())
						  nodeClass = nodeClassIter->second;
				  });
	return nodeClass;
}

/**
 * Returns the types loaded.
 */
map<string, VuoCompilerType *> VuoCompiler::Environment::getTypes(void)
{
	__block map<string, VuoCompilerType *> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = types;
				  });
	return ret;
}

/**
 * Returns the type with the given @a moduleKey, or null if no type by that name has been loaded.
 */
VuoCompilerType * VuoCompiler::Environment::getType(const string &moduleKey)
{
	__block VuoCompilerType *type = NULL;
	dispatch_sync(environmentQueue, ^{
					  map<string, VuoCompilerType *>::iterator typeIter = types.find(moduleKey);
					  if (typeIter != types.end())
						  type = typeIter->second;
				  });
	return type;
}

/**
 * Returns the library modules loaded.
 */
map<string, VuoCompilerModule *> VuoCompiler::Environment::getLibraryModules(void)
{
	__block map<string, VuoCompilerModule *> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = libraryModules;
				  });
	return ret;
}

/**
 * Returns the library modules with the given @a moduleKey, or null if no library module by that name has been loaded.
 */
VuoCompilerModule * VuoCompiler::Environment::getLibraryModule(const string &moduleKey)
{
	__block VuoCompilerModule *libraryModule = NULL;
	dispatch_sync(environmentQueue, ^{
					  map<string, VuoCompilerModule *>::iterator libraryModuleIter = libraryModules.find(moduleKey);
					  if (libraryModuleIter != libraryModules.end())
						  libraryModule = libraryModuleIter->second;
				  });
	return libraryModule;
}

/**
 * Returns the node set with the given name, or null no such node set been loaded.
 */
VuoNodeSet * VuoCompiler::Environment::findNodeSet(const string &name)
{
	__block VuoNodeSet *nodeSet = NULL;

	dispatch_sync(environmentQueue, ^{
					  map<string, VuoNodeSet *>::iterator nodeSetIter = nodeSetForName.find(name);
					  if (nodeSetIter != nodeSetForName.end())
					  {
						  nodeSet = nodeSetIter->second;
					  }
				  });

	return nodeSet;
}

/**
 * Adds a search path for node classes, types, and library modules.
 */
void VuoCompiler::Environment::addModuleSearchPath(const string &path)
{
	dispatch_sync(environmentQueue, ^{
					  moduleSearchPaths.push_back(path);
				  });
}

/**
 * Returns the search paths for node classes, types, and library modules.
 */
vector<string> VuoCompiler::Environment::getModuleSearchPaths(void)
{
	__block vector<string> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = moduleSearchPaths;
				  });
	return ret;
}

/**
 * Adds a search path for header/include files.
 */
void VuoCompiler::Environment::addHeaderSearchPath(const string &path)
{
	dispatch_sync(environmentQueue, ^{
					  headerSearchPaths.push_back(path);
				  });
}

/**
 * Returns the search paths for header/include files.
 */
vector<string> VuoCompiler::Environment::getHeaderSearchPaths(void)
{
	__block vector<string> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = headerSearchPaths;
				  });
	return ret;
}

/**
 * Adds a search path for libraries (other than Vuo library modules).
 */
void VuoCompiler::Environment::addLibrarySearchPath(const string &path)
{
	dispatch_sync(environmentQueue, ^{
					  librarySearchPaths.push_back(path);
				  });
}

/**
 * Returns the search paths for libraries (other than Vuo library modules).
 */
vector<string> VuoCompiler::Environment::getLibrarySearchPaths(void)
{
	__block vector<string> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = librarySearchPaths;
				  });
	return ret;
}

/**
 * Adds a search path for frameworks.
 */
void VuoCompiler::Environment::addFrameworkSearchPath(const string &path)
{
	dispatch_sync(environmentQueue, ^{
					  frameworkSearchPaths.push_back(path);
				  });
}

/**
 * Returns the search paths for frameworks.
 */
vector<string> VuoCompiler::Environment::getFrameworkSearchPaths(void)
{
	__block vector<string> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = frameworkSearchPaths;
				  });
	return ret;
}

static const std::locale VuoCompiler_locale;	///< For hashing strings.
static const std::collate<char> &VuoCompiler_collate = std::use_facet<std::collate<char> >(VuoCompiler_locale);	///< For hashing strings.

/**
 * Returns a hash of the specified string, to optimize std::map use.
 */
static inline long hashString(string s)
{
	return VuoCompiler_collate.hash(s.data(), s.data()+s.length());
}

/**
 * Data for loadModulesIntoCombinedEnvironment.
 */
struct ModuleInfo
{
	VuoFileUtilities::File *file;
	string searchPath;
	int env;
};

/**
 * Loads node classes and types from any directories in moduleSearchPaths that have not already been loaded.
 *
 * This function should be called on VuoCompiler::combinedEnvironment.
 */
void VuoCompiler::Environment::loadModulesIntoCombinedEnvironment(Environment *myEnvironment, Environment *sharedEnvironment,
																  bool shouldLoadAllModules, set<string> &modulesToLoad)
{
	dispatch_sync(environmentQueue, ^{
					  bool wereModulesLoaded = false;
					  Environment *envs[2] = { sharedEnvironment, myEnvironment };

					  if (shouldLoadAllModules)
					  {
						  // Load all modules from all search paths.

						  for (int i = 0; i < 2; ++i)
						  {
							  for (vector<string>::iterator j = envs[i]->moduleSearchPaths.begin(); j != envs[i]->moduleSearchPaths.end(); ++j)
							  {
								  string path = *j;
								  if (! envs[i]->isModuleSearchPathLoaded[path])
								  {
									  set<VuoFileUtilities::File *> moduleFiles = envs[i]->listModules(path);
									  for (set<VuoFileUtilities::File *>::iterator k = moduleFiles.begin(); k != moduleFiles.end(); ++k)
									  {
										  VuoFileUtilities::File *moduleFile = *k;
										  envs[i]->loadModule(moduleFile, path);
									  }
									  envs[i]->isModuleSearchPathLoaded[path] = true;
									  wereModulesLoaded = true;
								  }
							  }
						  }
					  }

					  if (! modulesToLoad.empty())
					  {
						  // Load the modules in modulesToLoad and their dependencies.

						  map<long, ModuleInfo> moduleInfo;
						  for (int i = 0; i < 2; ++i)
						  {
							  for (vector<string>::iterator j = envs[i]->moduleSearchPaths.begin(); j != envs[i]->moduleSearchPaths.end(); ++j)
							  {
								  string path = *j;
								  set<VuoFileUtilities::File *> moduleFiles = envs[i]->listModules(path);
								  for (set<VuoFileUtilities::File *>::iterator k = moduleFiles.begin(); k != moduleFiles.end(); ++k)
								  {
									  VuoFileUtilities::File *moduleFile = *k;
									  string moduleKey, dir, ext;
									  VuoFileUtilities::splitPath(moduleFile->getRelativePath(), dir, moduleKey, ext);

									  long hash = hashString(moduleKey);
									  moduleInfo[hash] = (ModuleInfo){ moduleFile, path, i };
								  }
							  }
						  }

						  while (! modulesToLoad.empty())
						  {
							  string moduleKey = *modulesToLoad.begin();
							  modulesToLoad.erase(moduleKey);
							  long moduleKeyHash = hashString(moduleKey);

							  bool alreadyLoadedModule = false;
							  for (int i = 0; i < 2; ++i)
							  {
								  if (envs[i]->nodeClasses.find(moduleKey) != envs[i]->nodeClasses.end() ||
									  envs[i]->types.find(moduleKey) != envs[i]->types.end() ||
									  envs[i]->libraryModules.find(moduleKey) != envs[i]->libraryModules.end())
								  {
									  alreadyLoadedModule = true;
								  }
							  }
							  if (alreadyLoadedModule)
								  continue;

							  map<long, ModuleInfo>::iterator moduleIter = moduleInfo.find(moduleKeyHash);
							  if (moduleIter == moduleInfo.end())
							  {
								  if (VuoCompilerMakeListNodeClass::isMakeListNodeClassName(moduleKey))
								  {
									  vector<string> parts = VuoStringUtilities::split(moduleKey, '.');
									  string itemType = parts.back();
									  modulesToLoad.insert(itemType);
									  modulesToLoad.insert(VuoType::listTypeNamePrefix + itemType);
									  continue;
								  }
								  else
								  {
									  bool foundGenericNodeClass = false;

									  vector<string> parts = VuoStringUtilities::split(moduleKey, '.');
									  for (int i = parts.size() - 1; i >= 1; --i)
									  {
										  vector<string> firstParts(parts.begin(), parts.begin() + i);
										  string genericNodeClass = VuoStringUtilities::join(firstParts, '.');
										  long genericNodeClassHash = hashString(genericNodeClass);

										  moduleIter = moduleInfo.find(genericNodeClassHash);
										  if (moduleIter != moduleInfo.end())
										  {
											  foundGenericNodeClass = true;
											  modulesToLoad.insert(parts.begin() + i, parts.end());
											  break;
										  }
									  }

									  if (! foundGenericNodeClass)
										  continue;
								  }
							  }

							  ModuleInfo mi = moduleIter->second;
							  VuoCompilerModule *module = envs[mi.env]->loadModule(mi.file, mi.searchPath);

							  if (module)
							  {
								  wereModulesLoaded = true;

								  set<string> dependencies = module->getDependencies();
								  modulesToLoad.insert(dependencies.begin(), dependencies.end());
							  }
						  }
					  }

					  if (wereModulesLoaded)
					  {
						  sharedEnvironment->reifyPortTypes(NULL);
						  myEnvironment->reifyPortTypes(sharedEnvironment);
						  updateCombinedEnvironment(myEnvironment, sharedEnvironment);
					  }
				  });
}

/**
 * Adds a node class to use when linking a composition.
 *
 * Typically, node classes are loaded from file with addModuleSearchPath().
 * This function is useful if adding a node class that is generated at compile time.
 *
 * This function should be called on VuoCompiler::combinedEnvironment.
 */
void VuoCompiler::Environment::addNodeClassToCombinedEnvironment(VuoCompilerNodeClass *nodeClass,
																 Environment *myEnvironment, Environment *sharedEnvironment)
{
	dispatch_sync(environmentQueue, ^{
					  dispatch_sync(llvmQueue, ^{
						  setTargetForModule(nodeClass->getModule());
					  });

					  string moduleKey = nodeClass->getBase()->getModuleKey();
					  myEnvironment->nodeClasses[moduleKey] = nodeClass;

					  myEnvironment->reifyPortTypes(sharedEnvironment);
					  updateCombinedEnvironment(myEnvironment, sharedEnvironment);
				  });
}

/**
 * Removes a node class from the list of node classes known to the compiler/linker, and destroys the node class.
 *
 * This function should be called on VuoCompiler::combinedEnvironment.
 */
void VuoCompiler::Environment::removeNodeClassFromCombinedEnvironment(string nodeClassName,
																	  Environment *myEnvironment, Environment *sharedEnvironment)
{
	dispatch_sync(environmentQueue, ^{
					  VuoCompilerNodeClass *nodeClass = NULL;

					  map<string, VuoCompilerNodeClass *>::iterator nodeClassIter = myEnvironment->nodeClasses.find(nodeClassName);
					  if (nodeClassIter != myEnvironment->nodeClasses.end())
					  {
						  nodeClass = nodeClassIter->second;
						  myEnvironment->nodeClasses.erase(nodeClassIter);
					  }
					  else
					  {
						  nodeClassIter = sharedEnvironment->nodeClasses.find(nodeClassName);
						  if (nodeClassIter != sharedEnvironment->nodeClasses.end())
						  {
							  nodeClass = nodeClassIter->second;
							  sharedEnvironment->nodeClasses.erase(nodeClassIter);
						  }
					  }

					  if (nodeClass)
					  {
						  Module *module = nodeClass->getModule();
						  VuoNodeClass *base = nodeClass->getBase();
						  delete nodeClass;
						  delete base;
						  deleteModule(module);

						  updateCombinedEnvironment(myEnvironment, sharedEnvironment);
					  }
				  });
}

/**
 * Returns a list of the all node classes, types, and library modules in the directory at @a path.
 *
 * The top level of the directory is searched for .vuonode, .vuonode+, .bc, and .bc+ files.
 * A .vuonode file may be either a module or an archive containing modules.
 * In the latter case, the .vuonode archive's top level is searched.
 *
 * @threadQueue{environmentQueue}
 */
set<VuoFileUtilities::File *> VuoCompiler::Environment::listModules(const string &path)
{
	map<string, VuoFileUtilities::File *> moduleFilesMap;
	map<string, map<string, VuoFileUtilities::File *> >::iterator moduleFilesIter = moduleFilesAtSearchPath.find(path);
	if (moduleFilesIter != moduleFilesAtSearchPath.end())
		moduleFilesMap = moduleFilesIter->second;
	else
	{
		set<string> moduleExtensions;
		moduleExtensions.insert("vuonode");
		moduleExtensions.insert("vuonode+");
		moduleExtensions.insert("bc");
		moduleExtensions.insert("bc+");
		set<string> archiveExtensions;
		archiveExtensions.insert("vuonode");
		set<VuoFileUtilities::File *> moduleFiles = VuoFileUtilities::findFilesInDirectory(path, moduleExtensions, archiveExtensions);

		for (set<VuoFileUtilities::File *>::iterator i = moduleFiles.begin(); i != moduleFiles.end(); ++i)
		{
			VuoFileUtilities::File *file = *i;
			moduleFilesMap[file->getRelativePath()] = file;
		}

		moduleFilesAtSearchPath[path] = moduleFilesMap;
	}

	set<VuoFileUtilities::File *> moduleFiles;
	for (map<string, VuoFileUtilities::File *>::iterator i = moduleFilesMap.begin(); i != moduleFilesMap.end(); ++i)
		moduleFiles.insert(i->second);

	return moduleFiles;
}

/**
 * Loads a node class, type, or library module from a file, and adds it to the environment.
 *
 * If a module with the same module key as @a moduleFile has already been added to the environment,
 * the module in @a moduleFile replaces it.
 *
 * @threadQueue{environmentQueue}
 */
VuoCompilerModule * VuoCompiler::Environment::loadModule(VuoFileUtilities::File *moduleFile, const string &searchPath)
{
	string moduleKey, dir, ext;
	VuoFileUtilities::splitPath(moduleFile->getRelativePath(), dir, moduleKey, ext);

	// Skip certain LLVM modules that definitely aren't Vuo modules to avoid adding struct types defined in them to the LLVM
	// context, resulting in mismatched struct types in code generation (e.g. %struct.NodeContext and %struct.NodeContext.1).
	if (VuoStringUtilities::beginsWith(moduleKey, "libVuo"))
		return NULL;

	size_t inputDataBytes;
	char *rawInputData;
	try
	{
		rawInputData = moduleFile->getContentsAsRawData(inputDataBytes);
	}
	catch (const exception &e)
	{
		VUserLog("Warning: Couldn't load module '%s'. Its file may have been deleted. (%s)", moduleKey.c_str(), e.what());
		return NULL;
	}
	char *processedInputData = NULL;

	bool moduleParseError = false;
	bool premiumModule = false;

	if ((ext == "vuonode+") || (ext == "bc+"))
	{
		encounteredPremiumModules.insert(moduleKey);

#ifdef PREMIUM_NODE_LOADER_ENABLED
		if (inputDataBytes <= INT_MAX)
			processedInputData = VuoPremium::getPremiumDataContent(rawInputData,
																   static_cast<int>(inputDataBytes),
																   moduleKey.c_str());
#endif

		if (!processedInputData)
		{
			moduleParseError = true;
			//VUserLog("Error: Couldn't extract premium content from file '%s'.", moduleFile->getRelativePath().c_str());
		}

		free(rawInputData);
		premiumModule = true;
	}
	else
		processedInputData = rawInputData;

	Module *module = NULL;
	if (!moduleParseError)
	{
		string moduleReadError;
		module = readModuleFromBitcodeData(processedInputData, inputDataBytes, moduleReadError);
		free(processedInputData);

		if (!module)
		{
			moduleParseError = true;
			VUserLog("Error: Couldn't parse module '%s': %s.", moduleFile->getRelativePath().c_str(), moduleReadError.c_str());
		}
	}

	if (!moduleParseError)
	{
		__block VuoCompilerModule *compilerModule;
		dispatch_sync(llvmQueue, ^{
						  compilerModule = VuoCompilerModule::newModule(moduleKey, module);
					  });

		if (compilerModule)
		{
			if (dynamic_cast<VuoCompilerNodeClass *>(compilerModule))
				nodeClasses[moduleKey] = static_cast<VuoCompilerNodeClass *>(compilerModule);
			else if (dynamic_cast<VuoCompilerType *>(compilerModule))
				types[moduleKey] = static_cast<VuoCompilerType *>(compilerModule);
			else
				libraryModules[moduleKey] = compilerModule;

			VuoNodeSet *nodeSet = VuoNodeSet::createNodeSetForModule(moduleFile);
			if (nodeSet)
			{
				map<string, VuoNodeSet *>::iterator nodeSetIter = nodeSetForName.find(nodeSet->getName());
				if (nodeSetIter == nodeSetForName.end())
				{
					nodeSetForName[nodeSet->getName()] = nodeSet;
				}
				else
				{
					delete nodeSet;
					nodeSet = nodeSetIter->second;
				}
				compilerModule->getPseudoBase()->setNodeSet(nodeSet);
			}

			compilerModule->setPremium(premiumModule);

			vector<string> builtInModuleSearchPaths = getBuiltInModuleSearchPaths();
			bool isBuiltIn = (find(builtInModuleSearchPaths.begin(), builtInModuleSearchPaths.end(), searchPath) != builtInModuleSearchPaths.end());
			compilerModule->setBuiltIn(isBuiltIn);

			return compilerModule;
		}
		else
		{
			deleteModule(module);
		}
	}

	return NULL;
}

/**
 * Updates the data-and-event ports of each known node class to match them up with known types.
 * This method needs to be called between when the last node class or type is loaded and
 * when a composition is compiled. It can be called multiple times.
 *
 * @threadQueue{environmentQueue}
 */
void VuoCompiler::Environment::reifyPortTypes(Environment *outerEnvironment)
{
	map<string, VuoCompilerNodeClass *> searchNodeClasses;
	map<string, VuoCompilerType *> searchTypes;

	if (outerEnvironment)
		searchNodeClasses.insert(outerEnvironment->nodeClasses.begin(), outerEnvironment->nodeClasses.end());
	searchNodeClasses.insert(nodeClasses.begin(), nodeClasses.end());

	if (outerEnvironment)
		searchTypes.insert(outerEnvironment->types.begin(), outerEnvironment->types.end());
	searchTypes.insert(types.begin(), types.end());

	for (map<string, VuoCompilerNodeClass *>::iterator i = searchNodeClasses.begin(); i != searchNodeClasses.end(); ++i)
	{
		VuoNodeClass *nodeClass = i->second->getBase();

		vector<VuoPortClass *> inputPortClasses = nodeClass->getInputPortClasses();
		vector<VuoPortClass *> outputPortClasses = nodeClass->getOutputPortClasses();
		vector<VuoPortClass *> portClasses;
		portClasses.insert(portClasses.end(), inputPortClasses.begin(), inputPortClasses.end());
		portClasses.insert(portClasses.end(), outputPortClasses.begin(), outputPortClasses.end());

		for (vector<VuoPortClass *>::iterator j = portClasses.begin(); j != portClasses.end(); ++j)
		{
			VuoCompilerPortClass *portClass = static_cast<VuoCompilerPortClass *>((*j)->getCompiler());
			VuoType *baseType = portClass->getDataVuoType();

			if (baseType && ! baseType->hasCompiler())
			{
				string typeName = baseType->getModuleKey();
				__block VuoCompilerType *reifiedType = NULL;

				VuoGenericType *genericType = dynamic_cast<VuoGenericType *>(baseType);
				if (genericType)
				{
					dispatch_sync(llvmQueue, ^{
									  reifiedType = VuoCompilerGenericType::newGenericType(genericType, searchTypes);
								  });
					if (reifiedType)
						genericTypes.insert( static_cast<VuoCompilerGenericType *>(reifiedType) );
				}
				else
				{
					map<string, VuoCompilerType *>::iterator reifiedTypeIter = searchTypes.find(typeName);
					if (reifiedTypeIter != searchTypes.end())
					{
						delete baseType;
						reifiedType = reifiedTypeIter->second;
					}
				}

				if (reifiedType)
					portClass->setDataVuoType(reifiedType->getBase());
			}
		}

		vector<VuoCompilerTriggerDescription *> triggers = nodeClass->getCompiler()->getTriggerDescriptions();
		for (vector<VuoCompilerTriggerDescription *>::iterator j = triggers.begin(); j != triggers.end(); ++j)
		{
			VuoCompilerTriggerDescription *trigger = *j;
			VuoType *baseType = trigger->getDataType();

			if (baseType && ! baseType->hasCompiler())
			{
				string typeName = baseType->getModuleKey();
				map<string, VuoCompilerType *>::iterator reifiedTypeIter = searchTypes.find(typeName);
				if (reifiedTypeIter != searchTypes.end())
				{
					delete baseType;
					VuoCompilerType *reifiedType = reifiedTypeIter->second;
					trigger->setDataType(reifiedType->getBase());
				}
			}
		}
	}
}

/**
 * Updates this environment to consist of @a myEnvironment layered on top of @a sharedEnvironment.
 *
 * This function should be called on VuoCompiler::combinedEnvironment.
 *
 * @threadQueue{environmentQueue}
 */
void VuoCompiler::Environment::updateCombinedEnvironment(Environment *myEnvironment, Environment *sharedEnvironment)
{
	nodeClasses.clear();
	types.clear();
	genericTypes.clear();
	nodeSetForName.clear();
	libraryModules.clear();
	isModuleSearchPathLoaded.clear();
	moduleSearchPaths.clear();
	headerSearchPaths.clear();
	librarySearchPaths.clear();
	frameworkSearchPaths.clear();

	Environment *envs[2] = { sharedEnvironment, myEnvironment };
	for (int i = 0; i < 2; ++i)
	{
		nodeClasses.insert(envs[i]->nodeClasses.begin(), envs[i]->nodeClasses.end());
		types.insert(envs[i]->types.begin(), envs[i]->types.end());
		genericTypes.insert(envs[i]->genericTypes.begin(), envs[i]->genericTypes.end());
		nodeSetForName.insert(envs[i]->nodeSetForName.begin(), envs[i]->nodeSetForName.end());
		libraryModules.insert(envs[i]->libraryModules.begin(), envs[i]->libraryModules.end());
		isModuleSearchPathLoaded.insert(envs[i]->isModuleSearchPathLoaded.begin(), envs[i]->isModuleSearchPathLoaded.end());
		moduleSearchPaths.insert(moduleSearchPaths.end(), envs[i]->moduleSearchPaths.begin(), envs[i]->moduleSearchPaths.end());
		headerSearchPaths.insert(headerSearchPaths.end(), envs[i]->headerSearchPaths.begin(), envs[i]->headerSearchPaths.end());
		librarySearchPaths.insert(librarySearchPaths.end(), envs[i]->librarySearchPaths.begin(), envs[i]->librarySearchPaths.end());
		frameworkSearchPaths.insert(frameworkSearchPaths.end(), envs[i]->frameworkSearchPaths.begin(), envs[i]->frameworkSearchPaths.end());
	}
}

/**
 * Returns the search paths for built-in node classes, types, and library modules.
 */
vector<string> VuoCompiler::Environment::getBuiltInModuleSearchPaths(void)
{
	vector<string> builtInModuleSearchPaths;

	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	if (! vuoFrameworkPath.empty())
	{
		builtInModuleSearchPaths.push_back(vuoFrameworkPath + "/Modules");
	}
	else
	{
		builtInModuleSearchPaths.push_back(VUO_ROOT "/library");
		builtInModuleSearchPaths.push_back(VUO_ROOT "/node");
		builtInModuleSearchPaths.push_back(VUO_ROOT "/type");
		builtInModuleSearchPaths.push_back(VUO_ROOT "/type/list");
	}

	return builtInModuleSearchPaths;
}

/**
 * Returns the search paths for built-in libraries (other than library modules).
 */
vector<string> VuoCompiler::Environment::getBuiltInLibrarySearchPaths(void)
{
	vector<string> builtInLibrarySearchPaths;

	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	if (! vuoFrameworkPath.empty())
	{
		builtInLibrarySearchPaths.push_back(vuoFrameworkPath + "/Modules");
	}
	else
	{
		builtInLibrarySearchPaths.push_back(VUO_ROOT "/library");
		builtInLibrarySearchPaths.push_back(VUO_ROOT "/node");
		builtInLibrarySearchPaths.push_back(VUO_ROOT "/type");
		builtInLibrarySearchPaths.push_back(VUO_ROOT "/type/list");
		builtInLibrarySearchPaths.push_back(VUO_ROOT "/runtime");

		builtInLibrarySearchPaths.push_back(GRAPHVIZ_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(GRAPHVIZ_ROOT "/lib/graphviz");
		builtInLibrarySearchPaths.push_back(JSONC_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(ZMQ_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(LEAP_ROOT);
		builtInLibrarySearchPaths.push_back(MUPARSER_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(FREEIMAGE_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(CURL_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(RTMIDI_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(RTAUDIO_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(GAMMA_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(ASSIMP_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(FFMPEG_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(LIBUSB_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(LIBFREENECT_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(OSCPACK_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(ZXING_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(LIBXML2_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(VUO_ROOT "/runtime");
	}

	return builtInLibrarySearchPaths;
}

/**
 * Adds the search paths needed by all compositions to this environment.
 *
 * This function should be called on VuoCompiler::sharedEnvironment.
 *
 * @threadQueue{environmentQueue}
 */
void VuoCompiler::Environment::addSearchPathsToSharedEnvironment(void)
{
	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	if (! vuoFrameworkPath.empty())
	{
		frameworkSearchPaths.push_back(vuoFrameworkPath + "/Modules/");
		frameworkSearchPaths.push_back(vuoFrameworkPath + "/Frameworks/");

		headerSearchPaths.push_back(vuoFrameworkPath + "/Headers/");
		headerSearchPaths.push_back(vuoFrameworkPath + "/Headers/macos");  // system headers installed by Xcode Command Line Tools
	}
	else
	{
		headerSearchPaths.push_back(VUO_ROOT "/library");
		headerSearchPaths.push_back(VUO_ROOT "/node");
		headerSearchPaths.push_back(VUO_ROOT "/node/vuo.font");
		headerSearchPaths.push_back(VUO_ROOT "/type");
		headerSearchPaths.push_back(VUO_ROOT "/type/list");
		headerSearchPaths.push_back(VUO_ROOT "/runtime");

		frameworkSearchPaths.push_back(SYPHON_ROOT);
	}

	vector<string> builtInModuleSearchPaths = getBuiltInModuleSearchPaths();
	moduleSearchPaths.insert(moduleSearchPaths.end(), builtInModuleSearchPaths.begin(), builtInModuleSearchPaths.end());
	vector<string> builtInLibrarySearchPaths = getBuiltInLibrarySearchPaths();
	librarySearchPaths.insert(librarySearchPaths.end(), builtInLibrarySearchPaths.begin(), builtInLibrarySearchPaths.end());

	// Allow system administrator to override Vuo.framework modules
	moduleSearchPaths.push_back(VuoFileUtilities::getSystemModulesPath());
	librarySearchPaths.push_back(VuoFileUtilities::getSystemModulesPath());

	// Allow user to override Vuo.framework and system-wide modules
	moduleSearchPaths.push_back(VuoFileUtilities::getUserModulesPath());
	librarySearchPaths.push_back(VuoFileUtilities::getUserModulesPath());

	moduleSearchPaths.push_back(getCachedModulesPath());
}

/**
 * Adds a module file after VuoCompiler::Environment::listModules() has already cached the list of
 * module files for the cache's Modules folder.
 */
void VuoCompiler::Environment::addCachedModulePathToSharedEnvironment(string moduleFileName)
{
	dispatch_sync(environmentQueue, ^{
					  string dir = getCachedModulesPath();
					  VuoFileUtilities::File *moduleFile = new VuoFileUtilities::File(dir, moduleFileName);
					  moduleFilesAtSearchPath[dir][moduleFile->getRelativePath()] = moduleFile;
				  });
}

/**
 * Creates a compiler instance that can be used for compiling and linking.
 */
VuoCompiler::VuoCompiler(void)
	: myEnvironment(true), combinedEnvironment(false)
{
	dispatch_sync(llvmQueue, ^{
					  if (! isLlvmInitialized)
					  {
						  isLlvmInitialized = true;

						  llvm::InitializeNativeTarget();

						  // If the Vuo compiler/linker...
						  //   1. Loads a node class that uses dispatch_object_t.
						  //   2. Generates code that uses dispatch_object_t.
						  //   3. Links the node class into a composition.
						  //   4. Generates more code that uses dispatch_object_t.
						  // ... then Step 4 ends up with the wrong llvm::Type for dispatch_object_t.
						  //
						  // A workaround is to generate some code that uses dispatch_object_t before doing Step 1.
						  //
						  // https://b33p.net/kosada/node/3845
						  // http://lists.cs.uiuc.edu/pipermail/llvmdev/2012-December/057075.html
						  Module module("", getGlobalContext());
						  VuoCompilerCodeGenUtilities::getDispatchObjectType(&module);

						  // Workaround for a possibly related error where the compiler ends up with the wrong
						  // llvm::Type for dispatch_semaphore_s.  https://b33p.net/kosada/node/10545
						  VuoCompilerCodeGenUtilities::getDispatchSemaphoreType(&module);

						  // Load the NodeContext and PortContext struct types preemptively to make sure that
						  // their fields get the right dispatch types. If these struct types were to be loaded
						  // first from a subcomposition module, they'd get the wrong dispatch types.
						  // https://b33p.net/kosada/node/11160
						  VuoCompilerCodeGenUtilities::getNodeContextType(&module);
						  VuoCompilerCodeGenUtilities::getPortContextType(&module);
					  }
				  });

	dependenciesCacheQueue = dispatch_queue_create("org.vuo.compiler.dependencies", NULL);
	modulesToLoadQueue = dispatch_queue_create("org.vuo.compiler.modules", NULL);
	shouldLoadAllModules = true;
	isVerbose = false;

	Environment *env = getSharedEnvironment();
	dispatch_sync(environmentQueue, ^{
					  combinedEnvironment.updateCombinedEnvironment( &myEnvironment, env );
				  });

	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	if (! vuoFrameworkPath.empty())
		clangPath = vuoFrameworkPath + "/Frameworks/llvm.framework/Versions/A/Helpers/clang";
	else
		clangPath = llvm::sys::Path(StringRef(LLVM_ROOT "/bin/clang"));
}

/**
 * Destructor.
 */
VuoCompiler::~VuoCompiler(void)
{
	dispatch_sync(cachedResourcesQueue, ^{});  // Wait for any asynchronous calls on this queue to complete.
}

/**
 * Returns the singleton shared by all VuoCompiler instances.
 */
VuoCompiler::Environment * VuoCompiler::getSharedEnvironment(void)
{
	dispatch_sync(environmentQueue, ^{
					  if (! sharedEnvironment)
					  {
						  sharedEnvironment = new Environment(true);
						  sharedEnvironment->addSearchPathsToSharedEnvironment();
					  }
				  });

	return sharedEnvironment;
}

/**
 * Returns a list of all compositions in the directory at @a path.
 *
 * The top level of the directory is searched for .vuo files.
 */
set<string> VuoCompiler::listCompositions(const string &path)
{
	map<string, set<string> >::iterator compositionPathsIter = compositionPathsAtSearchPath.find(path);
	if (compositionPathsIter != compositionPathsAtSearchPath.end())
		return compositionPathsIter->second;

	set<string> compositionPaths;

	set<string> compositionExtensions;
	compositionExtensions.insert("vuo");
	set<VuoFileUtilities::File *> compositionFiles = VuoFileUtilities::findFilesInDirectory(path, compositionExtensions, set<string>());
	for (set<VuoFileUtilities::File *>::iterator i = compositionFiles.begin(); i != compositionFiles.end(); ++i)
	{
		VuoFileUtilities::File *compositionFile = *i;

		string dir, file, ext;
		VuoFileUtilities::splitPath(compositionFile->getRelativePath(), dir, file, ext);
		string compositionPath = path + "/" + file + "." + ext;
		compositionPaths.insert(compositionPath);

		delete compositionFile;
	}

	compositionPathsAtSearchPath[path] = compositionPaths;

	return compositionPaths;
}

/**
 * Loads node classes and types from any directories in the module search paths that have not already been loaded.
 *
 * In this class, the modules for node classes, types, and library modules are loaded lazily.
 * They are loaded the first time they are accessed (by strategically placed calls to this function).
 * Specifically, they are loaded the first time compiling a composition, linking a composition, or otherwise
 * accessing the collections of node classes or types. They are not loaded when compiling a node class.
 *
 * Likewise, subcomposition source (.vuo) files are compiled lazily. They are only compiled just before they
 * need to be loaded as node classes.
 */
void VuoCompiler::loadModulesIfNeeded(void)
{
	dispatch_sync(hasCleanedCompiledSubcompositionDirQueue, ^{
					  if (! hasCleanedCompiledSubcompositionDir)
					  {
						  // Delete any compiled subcompositions for which the composition source no longer exists.
						  string compiledSubcompositionDir = getCachedModulesPath();
						  set<string> extensions;
						  extensions.insert("vuonode");
						  set<VuoFileUtilities::File *> compiledSubcompositionFiles = VuoFileUtilities::findFilesInDirectory(compiledSubcompositionDir, extensions, set<string>());
						  for (set<VuoFileUtilities::File *>::iterator i = compiledSubcompositionFiles.begin(); i != compiledSubcompositionFiles.end(); ++i)
						  {
							  VuoFileUtilities::File *compiledSubcompositionFile = *i;

							  string dir, file, ext;
							  VuoFileUtilities::splitPath(compiledSubcompositionFile->getRelativePath(), dir, file, ext);
							  string subcompositionPath = VuoFileUtilities::getUserModulesPath() + "/" + file + ".vuo";

							  if (! VuoFileUtilities::fileExists(subcompositionPath))
							  {
								  string compiledSubcompositionPath = compiledSubcompositionDir + "/" + compiledSubcompositionFile->getRelativePath();
								  VuoFileUtilities::deleteFile(compiledSubcompositionPath);
							  }

							  delete compiledSubcompositionFile;
						  }

						  hasCleanedCompiledSubcompositionDir = true;
					  }
				  });

	// Form a list of subcompositions that need to be compiled in order to fulfill the responsibilities of this call
	// (based on `shouldLoadAllModules` and `modulesToLoad`).
	//
	// Avoid infinite recursion (load modules -> compile subcomposition -> load modules -> ...) by using
	// subcompositionsBeingCompiled to keep track of the compositions being compiled by this call (last item
	// in subcompositionsBeingCompiled) and calls higher up the call stack (rest of subcompositionsBeingCompiled).

	__block set<string> subcompositionsToCompile;
	__block set<string> modulesToLoadThisIteration;
	dispatch_sync(modulesToLoadQueue, ^{
					  subcompositionModules.clear();

					  vector<string> moduleSearchPaths = combinedEnvironment.getModuleSearchPaths();
					  for (vector<string>::iterator i = moduleSearchPaths.begin(); i != moduleSearchPaths.end(); ++i)
					  {
						  string searchPath = *i;

						  set<string> subcompositionPaths = listCompositions(searchPath);
						  for (set<string>::iterator j = subcompositionPaths.begin(); j != subcompositionPaths.end(); ++j)
						  {
							  string subcompositionPath = *j;

							  string dir, file, ext;
							  VuoFileUtilities::splitPath(subcompositionPath, dir, file, ext);

							  if (! VuoFileUtilities::fileExists(subcompositionPath))
							  {
								  compositionPathsAtSearchPath[searchPath].erase(subcompositionPath);
								  continue;
							  }

							  subcompositionModules.insert(file);

							  if ((subcompositionsBeingCompiled.empty() && shouldLoadAllModules) || modulesToLoad.find(file) != modulesToLoad.end())
							  {
								  if (find(subcompositionsBeingCompiled.begin(), subcompositionsBeingCompiled.end(), subcompositionPath) == subcompositionsBeingCompiled.end())
								  {
									  subcompositionsToCompile.insert(subcompositionPath);
								  }
							  }
						  }
					  }

					  set_difference(modulesToLoad.begin(), modulesToLoad.end(),
									 subcompositionModules.begin(), subcompositionModules.end(),
									 std::inserter(modulesToLoadThisIteration, modulesToLoadThisIteration.end()));
				  });

	// Compile subcompositions and load modules.
	//
	// Subcompositions are compiled and loaded one per iteration. Compiling and loading them one at a time ensures that
	// the current subcomposition is made available as a node class before the next subcomposition is compiled, in case
	// the next subcomposition contains an instance of the current subcomposition.
	//
	// On the first iteration, all non-subcomposition modules for which this call is responsible are also loaded.

	do
	{
		__block string subcompositionChosenToCompile;
		dispatch_sync(modulesToLoadQueue, ^{
						  if (! subcompositionsToCompile.empty())
						  {
							  set<string>::iterator iter = subcompositionsToCompile.begin();
							  subcompositionChosenToCompile = *iter;
							  subcompositionsBeingCompiled.push_back(subcompositionChosenToCompile);
							  subcompositionsToCompile.erase(iter);
						  }
					  });

		string subcompositionModuleChosenToCompile;
		bool gotErrorForSubcomposition = false;
		if (! subcompositionChosenToCompile.empty())
		{
			string dir, ext;
			VuoFileUtilities::splitPath(subcompositionChosenToCompile, dir, subcompositionModuleChosenToCompile, ext);

			try
			{
				bool compiled = compileSubcompositionIfNeeded(subcompositionChosenToCompile);
				if (compiled)
					sharedEnvironment->addCachedModulePathToSharedEnvironment(subcompositionModuleChosenToCompile + ".vuonode");
			}
			catch (VuoCompilerException &e)
			{
				gotErrorForSubcomposition = true;
			}
		}

		dispatch_sync(modulesToLoadQueue, ^{
						  if (! subcompositionChosenToCompile.empty())
						  {
							  subcompositionsBeingCompiled.pop_back();

							  if (! gotErrorForSubcomposition)
							  {
								  modulesToLoadThisIteration.insert(subcompositionModuleChosenToCompile);
							  }
							  else
							  {
								  modulesToLoad.erase(subcompositionModuleChosenToCompile);
							  }
						  }

						  set<string> remainingModulesToLoad;
						  set_difference(modulesToLoad.begin(), modulesToLoad.end(),
										 modulesToLoadThisIteration.begin(), modulesToLoadThisIteration.end(),
										 std::inserter(remainingModulesToLoad, remainingModulesToLoad.end()));
						  modulesToLoad = remainingModulesToLoad;

						  combinedEnvironment.loadModulesIntoCombinedEnvironment( &myEnvironment, getSharedEnvironment(), shouldLoadAllModules, modulesToLoadThisIteration );
					  });
	}
	while (! subcompositionsToCompile.empty());
}

/**
 * Initializes the premium node loader with the license information provided.
 *
 * This function should be called before attempting to load any premium moduless.
 */
void VuoCompiler::setLicense(string licenseContent, string licenseSignature)
{
#ifdef PREMIUM_NODE_LOADER_ENABLED
	VuoPremium::initializeWithLicense(licenseContent, licenseSignature);
#endif
}

/**
 * Initializes the premium node loader with the license information stored in the user's org.vuo.Editor settings file.
 */
void VuoCompiler::loadStoredLicense(bool showLicenseWarning)
{
#ifdef PREMIUM_NODE_LOADER_ENABLED
	VuoPremium::loadStoredLicense(showLicenseWarning);
#endif
}

/**
 * Updates the nodes and ports of the composition to have the correct backing types for generic types.
 */
void VuoCompiler::reifyGenericPortTypes(VuoCompilerComposition *composition)
{
	set<VuoNode *> nodes = composition->getBase()->getNodes();
	for (set<VuoNode *>::iterator i = nodes.begin(); i != nodes.end(); ++i)
		reifyGenericPortTypes(*i);
}

/**
 * Updates the ports of the node to have the correct backing types for generic types.
 */
void VuoCompiler::reifyGenericPortTypes(VuoNode *node)
{
	VuoCompilerSpecializedNodeClass *nodeClass = dynamic_cast<VuoCompilerSpecializedNodeClass *>(node->getNodeClass()->getCompiler());
	if (! nodeClass)
		return;

	// Reify any generic types on the node that don't already have a compiler detail.

	vector<VuoPort *> inputPorts = node->getInputPorts();
	vector<VuoPort *> outputPorts = node->getOutputPorts();
	vector<VuoPort *> ports;
	ports.insert(ports.end(), inputPorts.begin(), inputPorts.end());
	ports.insert(ports.end(), outputPorts.begin(), outputPorts.end());

	for (vector<VuoPort *>::iterator j = ports.begin(); j != ports.end(); ++j)
	{
		VuoCompilerPort *port = static_cast<VuoCompilerPort *>((*j)->getCompiler());
		VuoGenericType *genericType = dynamic_cast<VuoGenericType *>(port->getDataVuoType());
		if (! genericType)
			continue;

		if (! genericType->hasCompiler())
		{
			__block VuoCompilerGenericType *reifiedType;
			dispatch_sync(llvmQueue, ^{
							  reifiedType = VuoCompilerGenericType::newGenericType(genericType, this);
						  });
			if (reifiedType)
				port->setDataVuoType(reifiedType->getBase());
		}
	}

	// Update the node class's backing to match the node's backing.

	nodeClass->updateBackingNodeClass(node, this);
}

/**
 * Compiles a node class, port type, or library module to LLVM bitcode.
 *
 * @param inputPath The file to compile, containing a C implementation of the node class, port type, or library module.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 */
void VuoCompiler::compileModule(string inputPath, string outputPath)
{
	compileModule(inputPath, outputPath, vector<string>());
}

/**
 * Compiles a node class, port type, or library module to LLVM bitcode.
 *
 * @param inputPath The file to compile, containing a C implementation of the node class, port type, or library module.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 * @param includePaths Directories with header files to be included when compiling.
 */
void VuoCompiler::compileModule(string inputPath, string outputPath, const vector<string> &includePaths)
{
	if (isVerbose)
		print();

	vector<string> allIncludePaths = includePaths;
	string preprocessedInputPath = inputPath;

	string tmpPreprocessedInputDir;
	string dir, file, ext;
	VuoFileUtilities::splitPath(inputPath, dir, file, ext);
	if (ext == "c")
	{
		string inputContents = VuoFileUtilities::readFileToString(inputPath);
		string preprocessedInputContents = inputContents;
		VuoCompilerSpecializedNodeClass::replaceGenericTypesWithBacking(preprocessedInputContents);
		if (inputContents != preprocessedInputContents)
		{
			// Unspecialized generic node class
			allIncludePaths.push_back(dir.empty() ? "." : dir);
			tmpPreprocessedInputDir = VuoFileUtilities::makeTmpDir(file);
			preprocessedInputPath = tmpPreprocessedInputDir + "/" + file + "." + ext;
			VuoFileUtilities::preserveOriginalFileName(preprocessedInputContents, file + "." + ext);
			VuoFileUtilities::writeStringToFile(preprocessedInputContents, preprocessedInputPath);
		}
	}

	vector<string> extraArgs;
	for (vector<string>::iterator i = allIncludePaths.begin(); i != allIncludePaths.end(); ++i)
	{
		extraArgs.push_back("-I");
		extraArgs.push_back(*i);
	}

	string macosxSdkFolder = "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/";
	if (VuoFileUtilities::fileExists(macosxSdkFolder + "MacOSX10.9.sdk"))
	{
		extraArgs.push_back("-isysroot");
		extraArgs.push_back(macosxSdkFolder + "MacOSX10.9.sdk");
	}
	else if (VuoFileUtilities::fileExists(macosxSdkFolder + "MacOSX10.10.sdk"))
	{
		extraArgs.push_back("-isysroot");
		extraArgs.push_back(macosxSdkFolder + "MacOSX10.10.sdk");
	}

	Module *module = readModuleFromC(preprocessedInputPath, extraArgs);
	if (! tmpPreprocessedInputDir.empty())
		remove(tmpPreprocessedInputDir.c_str());
	if (! module)
	{
		vector<VuoCompilerError> errors;
		string details = "The node <code>" + file + "</code> couldn't be compiled to bitcode.  Check the OS X Console for details.";
		VuoCompilerError error("Broken node", details, set<VuoNode *>(), set<VuoCable *>());
		errors.push_back(error);
		throw VuoCompilerException(errors);
	}

	string moduleKey = getModuleNameForPath(inputPath);
	dispatch_sync(llvmQueue, ^{
					  VuoCompilerModule *compilerModule = VuoCompilerModule::newModule(moduleKey, module);
					  if (! compilerModule)
					  {
						  VUserLog("Error: Didn't recognize '%s' as a node class, type, or library.", inputPath.c_str());
						  return;
					  }

					  setTargetForModule(module, target);
					  writeModuleToBitcode(module, outputPath);

					  delete module;
				  });
}

/**
 * Compiles a composition to LLVM bitcode.
 *
 * If the composition contains generic nodes, then it may be modified to allow these generic nodes to be compiled.
 * See reifyGenericPortTypes() for more information.
 *
 * @param composition The composition to compile.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 * @param isTopLevelComposition True if the composition is top-level, false if it's a subcomposition.
 * @param isLiveCodeable True if the composition is intended to be used in live coding (either as a top-level composition or as a subcomposition).
 * @throw VuoCompilerException The composition is invalid.
 */
void VuoCompiler::compileComposition(VuoCompilerComposition *composition, string outputPath, bool isTopLevelComposition, bool isLiveCodeable)
{
	__block set<string> subcompositionModulesCopy;
	if (! isTopLevelComposition)
	{
		dispatch_sync(modulesToLoadQueue, ^{
						  subcompositionModulesCopy = subcompositionModules;
					  });
	}
	composition->check(subcompositionModulesCopy);

	reifyGenericPortTypes(composition);

	string moduleKey = getModuleNameForPath(outputPath);
	VuoCompilerBitcodeGenerator *generator = VuoCompilerBitcodeGenerator::newBitcodeGeneratorFromComposition(composition,
																											 isTopLevelComposition,
																											 isLiveCodeable,
																											 moduleKey, this);
	if (telemetry == "console")
		generator->setDebugMode(true);

	dispatch_sync(llvmQueue, ^{
					  Module *module = generator->generateBitcode();
					  setTargetForModule(module, target);
					  writeModuleToBitcode(module, outputPath);
				  });

	delete generator;
}

/**
 * Compiles a composition, read from file, to LLVM bitcode.
 *
 * @param inputPath The .vuo file containing the composition.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 * @param isTopLevelComposition True if the composition is top-level, false if it's a subcomposition.
 * @param isLiveCodeable True if the composition is intended to be used in live coding (either as a top-level composition or as a subcomposition).
 * @throw VuoCompilerException The composition is invalid.
 */
void VuoCompiler::compileComposition(string inputPath, string outputPath, bool isTopLevelComposition, bool isLiveCodeable)
{
	if (isVerbose)
		print();

	string compositionString = VuoFileUtilities::readFileToString(inputPath);
	return compileCompositionString(compositionString, outputPath, isTopLevelComposition, isLiveCodeable);
}

/**
 * Compiles the composition, read from a string, to LLVM bitcode.
 *
 * @param compositionString A string containing the composition.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 * @param isTopLevelComposition True if the composition is top-level, false if it's a subcomposition.
 * @param isLiveCodeable True if the composition is intended to be used in live coding (either as a top-level composition or as a subcomposition).
 * @throw VuoCompilerException The composition is invalid.
 */
void VuoCompiler::compileCompositionString(const string &compositionString, string outputPath, bool isTopLevelComposition, bool isLiveCodeable)
{
	VuoCompilerComposition *composition = VuoCompilerComposition::newCompositionFromGraphvizDeclaration(compositionString, this);
	compileComposition(composition, outputPath, isTopLevelComposition, isLiveCodeable);

	VuoComposition *baseComposition = composition->getBase();
	delete composition;
	delete baseComposition;
}

/**
 * Compiles the composition to a node class, unless the node class file already exists and is up-to-date.
 *
 * @throw VuoCompilerException The composition is invalid.
 */
bool VuoCompiler::compileSubcompositionIfNeeded(string compositionPath)
{
	// Check if the subcomposition needs to be (re)compiled.

	if (errorsLoadingModules.find(compositionPath) != errorsLoadingModules.end())
		return false;

	string cachedModulesPath = getCachedModulesPath();

	string dir, file, ext;
	VuoFileUtilities::splitPath(compositionPath, dir, file, ext);
	string compiledCompositionPath = cachedModulesPath + "/" + file + ".vuonode";

	if (VuoFileUtilities::fileExists(compiledCompositionPath) &&
			VuoFileUtilities::getFileLastModifiedInSeconds(compiledCompositionPath) >= VuoFileUtilities::getFileLastModifiedInSeconds(compositionPath))
		return false;

	VuoFileUtilities::makeDir(cachedModulesPath);

	// Uninstall any other subcompositions that contain the subcomposition about to be compiled,
	// so that they'll get recompiled the next time they're used (and the subcomposition about to
	// be compiled won't be able to call them, i.e. call itself recursively).

	__block set<string> subcompositionModulesCopy;
	dispatch_sync(modulesToLoadQueue, ^{
					  subcompositionModulesCopy = subcompositionModules;
				  });
	list<string> dirtySubcompositions(1, file);
	while (! dirtySubcompositions.empty())
	{
		string dirtySubcomposition = dirtySubcompositions.front();
		dirtySubcompositions.pop_front();

		for (set<string>::iterator i = subcompositionModulesCopy.begin(); i != subcompositionModulesCopy.end(); ++i)
		{
			string nodeClassName = *i;

			VuoCompilerNodeClass *nodeClass = combinedEnvironment.getNodeClass(nodeClassName);
			if (nodeClass)
			{
				set<string> dependencies = nodeClass->getDependencies();
				if (dependencies.find(dirtySubcomposition) != dependencies.end())
				{
					uninstallSubcomposition(nodeClassName);
					dirtySubcompositions.push_back(nodeClassName);
				}
			}
		}
	}

	// Compile the subcomposition.

	try
	{
		compileComposition(compositionPath, compiledCompositionPath, false);
	}
	catch (VuoCompilerException &e)
	{
		errorsLoadingModules[compositionPath] = e;
		throw e;
	}

	return true;
}

/**
 * Installs the composition as a node class in the user-specific Vuo Modules folder.
 *
 * The file at @a compositionPath is compiled as a node class.
 * The compiled node class is placed in the cached Modules folder. That node class is returned.
 *
 * @throw VuoCompilerException The composition could not be compiled.
 */
VuoCompilerNodeClass * VuoCompiler::installSubcomposition(string compositionPath)
{
	string dir, file, ext;
	VuoFileUtilities::splitPath(compositionPath, dir, file, ext);
	string nodeClassName = file;

	uninstallSubcomposition(nodeClassName);

	dispatch_sync(modulesToLoadQueue, ^{
					  modulesToLoad.insert(nodeClassName);
					  compositionPathsAtSearchPath[VuoFileUtilities::getUserModulesPath()].insert(compositionPath);
				  });

	VuoCompilerNodeClass *nodeClass = getNodeClass(nodeClassName);

	if (! nodeClass)
	{
		map<string, VuoCompilerException>::iterator iter = errorsLoadingModules.find(compositionPath);
		if (iter != errorsLoadingModules.end())
		{
			VuoCompilerException e = iter->second;
			errorsLoadingModules.erase(iter);
			throw e;
		}
	}

	return nodeClass;
}

/**
 * Uninstalls the subcomposition node class from the user-specific Vuo Modules folder.
 */
void VuoCompiler::uninstallSubcomposition(string nodeClassName)
{
	string compiledSubcompositionPath = getCachedModulesPath() + "/" + nodeClassName + ".vuonode";
	VuoFileUtilities::deleteFile(compiledSubcompositionPath);

	dispatch_sync(cachedResourcesQueue, ^{
					  combinedEnvironment.removeNodeClassFromCombinedEnvironment(nodeClassName, &myEnvironment, sharedEnvironment);
					  hasTriedCachedResources[1] = false;
				  });

	dispatch_sync(dependenciesCacheQueue, ^{
					  compatibleDependenciesCache.erase(nodeClassName);
					  incompatibleDependenciesCache.erase(nodeClassName);
				  });
}

/**
 * Turns a compiled composition into an executable by
 * linking in all of its dependencies and adding a main function.
 *
 * @param inputPath Path to the compiled composition (an LLVM bitcode file).
 * @param outputPath Path where the resulting executable should be placed.
 * @param optimization Controls the time it takes to link the composition and the size and dependencies of the
 *			resulting executable.
 * @param isApp If true, the resulting executable can be added to an app bundle.
 *			If false, the resulting executable will be headless unless the composition contains a window.
 * @param rPath An optional @c -rpath argument to be passed to clang.
 * @throw VuoCompilerException At least one of the dependencies is incompatible with the targets for building the composition,
 *			or the linker encountered errors and failed.
 */
void VuoCompiler::linkCompositionToCreateExecutable(string inputPath, string outputPath, Optimization optimization,
													bool isApp, string rPath)
{
	linkCompositionToCreateExecutableOrDynamicLibrary(inputPath, outputPath, optimization, false, isApp, rPath);
}

/**
 * Turns a compiled composition into a dynamic library by
 * linking in all of its dependencies.
 *
 * @param inputPath Path to the compiled composition (an LLVM bitcode file).
 * @param outputPath Path where the resulting dynamic library should be placed.
 * @param optimization Controls the time it takes to link the composition and the size and dependencies of the
 *			resulting dynamic library.
 * @throw VuoCompilerException At least one of the dependencies is incompatible with the targets for building the composition,
 *			or the linker encountered errors and failed.
 */
void VuoCompiler::linkCompositionToCreateDynamicLibrary(string inputPath, string outputPath, Optimization optimization)
{
	linkCompositionToCreateExecutableOrDynamicLibrary(inputPath, outputPath, optimization, true);
}

#include "VuoTimeUtilities.hh"
/**
 * Creates an executable or dynamic library that contains the composition and its dependencies.
 *
 * If creating an executable, a main function is added.
 *
 * @param compiledCompositionPath Path to the compiled composition (n LLVM bitcode file).
 * @param linkedCompositionPath Path where the resulting executable or dynamic library should be placed.
 * @param optimization Controls the time it takes to link the composition and the size and dependencies of the
 *			resulting executable or dynamic library.
 * @param isDylib True if creating a dynamic library, false if creating an executable.
 * @param isApp If true, the resulting executable can be added to an app bundle.
 *			If false, the resulting executable will be headless unless the composition contains a window.
 * @param rPath An optional @c -rpath argument to be passed to clang.
 * @throw VuoCompilerException At least one of the dependencies is incompatible with the targets for building the composition,
 *			or the linker encountered errors and failed.
 */
void VuoCompiler::linkCompositionToCreateExecutableOrDynamicLibrary(string compiledCompositionPath, string linkedCompositionPath,
																	Optimization optimization, bool isDylib, bool isApp, string rPath)
{
	if (isVerbose)
		print();

	if (optimization == Optimization_FastBuildExistingCache)
		shouldLoadAllModules = false;

	set<string> dependencies = getDependenciesForComposition(compiledCompositionPath);
	dependencies.insert(getRuntimeDependency());
	if (! isDylib)
		dependencies.insert(getRuntimeMainDependency());
	if (isApp)
	{
		/// @todo This is obsolete now that VuoApp_init() needs to be explicitly called (instead of merely linked in and called via static initializer).
		string applicationDependency = getApplicationDependency();
		set<string> incompatibleDependencies;
		getDependenciesRecursively(applicationDependency, dependencies, incompatibleDependencies);
	}
	set<Module *> modules;
	set<string> libraries;
	set<string> frameworks;
	getLinkerInputs(dependencies, optimization, modules, libraries, frameworks);

	libraries.insert(compiledCompositionPath);

	link(linkedCompositionPath, modules, libraries, frameworks, isDylib, rPath);
}

/**
 * Creates one dynamic library for the composition by itself and, if needed, another dynamic library for the
 * node classes and other resources that are dependencies of the composition.
 *
 * @param compiledCompositionPath Path to the compiled composition (an LLVM bitcode file).
 * @param linkedCompositionPath Path where the resulting dynamic library for the composition should be placed.
 * @param newLinkedResourcePath Path where the resulting dynamic library for the composition's resources should be placed.
 *				The dynamic library is only created if this version of the composition requires resources that are not in
 *				@c alreadyLinkedResources. When this function returns, if the dynamic library was created, then this
 *				argument is the same as when it was passed in; otherwise, this argument is the empty string.
 * @param alreadyLinkedResourcePaths Paths where the resulting dynamic libraries for the composition's resources have
 *				been placed in previous calls to this function. When this function returns, if a dynamic library was
 *				created at @c newLinkedResourcePath, it will be the last element in this list.
 * @param alreadyLinkedResources Names of resources that have been linked into the composition in previous calls to this
 *				function. When this function returns, any new resources will have been added to this list.
 * @throw VuoCompilerException At least one of the dependencies is incompatible with the targets for building the composition,
 *				or the linker encountered errors and failed. The values of @a newLinkedResourcePath,
 *				@a alreadyLinkedResourcePaths, and @a alreadyLinkedResources are unchanged.
 */
void VuoCompiler::linkCompositionToCreateDynamicLibraries(string compiledCompositionPath, string linkedCompositionPath,
														  string &newLinkedResourcePath, vector<string> &alreadyLinkedResourcePaths,
														  set<string> &alreadyLinkedResources)
{
	if (isVerbose)
		print();

	// Wait to update the passed-by-reference arguments until the end of this function, in case an exception is thrown.
	string tmpNewLinkedResourcePath = newLinkedResourcePath;
	vector<string> tmpAlreadyLinkedResourcePaths = alreadyLinkedResourcePaths;
	set<string> tmpAlreadyLinkedResources = alreadyLinkedResources;

	// Get the dependencies used by the new resources and not the previous resources.
	set<string> newDependencies = getDependenciesForComposition(compiledCompositionPath);
	set<string> newDependenciesCopy = newDependencies;
	for (set<string>::iterator i = newDependenciesCopy.begin(); i != newDependenciesCopy.end(); ++i)
		if (tmpAlreadyLinkedResources.find(*i) != tmpAlreadyLinkedResources.end())
			newDependencies.erase(newDependencies.find(*i));

	// Get the dynamic libraries and frameworks used by the new and previous resources.
	set<string> dylibs;
	set<string> frameworks;
	{
		set<Module *> modules;
		set<string> libraries;

		tmpAlreadyLinkedResources.insert(newDependencies.begin(), newDependencies.end());

		getLinkerInputs(tmpAlreadyLinkedResources, Optimization_FastBuild, modules, libraries, frameworks);

		for (set<string>::iterator i = libraries.begin(); i != libraries.end(); ++i)
			if (VuoStringUtilities::endsWith(*i, ".dylib"))
				dylibs.insert(*i);
	}

	// Link the new resource dylib, if needed.
	if (! newDependencies.empty())
	{
		set<Module *> modules;
		set<string> libraries;

		libraries.insert(tmpAlreadyLinkedResourcePaths.begin(), tmpAlreadyLinkedResourcePaths.end());
		libraries.insert(dylibs.begin(), dylibs.end());
		getLinkerInputs(newDependencies, Optimization_FastBuild, modules, libraries, frameworks);

		link(tmpNewLinkedResourcePath, modules, libraries, frameworks, true);

		tmpAlreadyLinkedResourcePaths.push_back(tmpNewLinkedResourcePath);
	}
	else
	{
		tmpNewLinkedResourcePath = "";
	}

	// Get the Vuo runtime dependency.
	string vuoRuntimePath;
	{
		set<Module *> modules;
		set<string> libraries;
		set<string> frameworks;

		set<string> dependencies;
		dependencies.insert(getRuntimeDependency());
		getLinkerInputs(dependencies, Optimization_FastBuild, modules, libraries, frameworks);
		vuoRuntimePath = *libraries.begin();
	}

	// Link the composition.
	{
		set<Module *> modules;
		set<string> libraries;

		libraries.insert(compiledCompositionPath);
		libraries.insert(vuoRuntimePath);
		libraries.insert(tmpAlreadyLinkedResourcePaths.begin(), tmpAlreadyLinkedResourcePaths.end());
		libraries.insert(dylibs.begin(), dylibs.end());
		link(linkedCompositionPath, modules, libraries, frameworks, true);
	}

	newLinkedResourcePath = tmpNewLinkedResourcePath;
	alreadyLinkedResourcePaths = tmpAlreadyLinkedResourcePaths;
	alreadyLinkedResources = tmpAlreadyLinkedResources;
}

/**
 * Returns the names of dependencies (node classes, types, libraries, and frameworks)
 * needed for linking the composition.
 *
 * This includes the composition's nodes, their dependencies, and the libraries needed
 * by every linked composition. It does not include the Vuo runtime or a main function.
 *
 * @throw VuoCompilerException At least one of the dependencies is incompatible with the targets for building the composition.
 */
set<string> VuoCompiler::getDependenciesForComposition(const string &compiledCompositionPath)
{
	set<string> dependencies;

	// Add the node classes in the top-level composition and their dependencies.
	__block set<string> directDependencies;
	string moduleKey = getModuleNameForPath(compiledCompositionPath);
	Module *module = readModuleFromBitcode(compiledCompositionPath);
	dispatch_sync(llvmQueue, ^{
					  VuoCompilerModule *compilerModule = VuoCompilerModule::newModule(moduleKey, module);
					  directDependencies = compilerModule->getDependencies();
					  delete compilerModule;
				  });

	dispatch_sync(modulesToLoadQueue, ^{
					  if (! shouldLoadAllModules)
					  {
						  modulesToLoad.clear();
						  modulesToLoad.insert(directDependencies.begin(), directDependencies.end());
					  }
				  });

	loadModulesIfNeeded();

	for (set<string>::iterator i = directDependencies.begin(); i != directDependencies.end(); ++i)
	{
		string dependency = *i;

		set<string> dependenciesToAdd;
		set<string> incompatibleDependencies;
		getDependenciesRecursively(dependency, dependenciesToAdd, incompatibleDependencies);

		if (incompatibleDependencies.empty())
		{
			dependencies.insert(dependenciesToAdd.begin(), dependenciesToAdd.end());
		}
		else
		{
			VuoCompilerTargetSet compositionTargets;
			compositionTargets.restrictToCurrentOperatingSystemVersion();

			string dependencyTargetString;
			VuoCompilerModule *module = getModule(dependency);
			if (module)
			{
				VuoCompilerTargetSet dependencyTargets = module->getCompatibleTargets();
				for (set<string>::iterator i = incompatibleDependencies.begin(); i != incompatibleDependencies.end(); ++i)
				{
					VuoCompilerModule *subModule = getModule(*i);
					if (subModule)
					{
						VuoCompilerTargetSet subDependencyTargets = subModule->getCompatibleTargets();
						dependencyTargets.restrictToBeCompatibleWithAllOf(subDependencyTargets);
					}
				}
				dependencyTargetString = dependencyTargets.toString();
			}
			else
				dependencyTargetString = "(unknown operating systems)";

			string details = dependency + " is only compatible with " + dependencyTargetString +
							 ", but this composition needs to run on " + compositionTargets.toString() + ".";
			vector<VuoCompilerError> errors;
			VuoCompilerError error("Node incompatible with operating system", details, set<VuoNode *>(), set<VuoCable *>());
			errors.push_back(error);
			throw VuoCompilerException(errors);
		}
	}

	// Add the libraries needed by every linked composition.
	vector<string> coreDependencies = getCoreVuoDependencies();
	dependencies.insert(coreDependencies.begin(), coreDependencies.end());

	return dependencies;
}

/**
 * Adds @a dependency and the names of all of its dependencies to @a compatibleDependencies and @a incompatibleDependencies.
 *
 * @param dependency The current dependency being searched for its dependencies.
 * @param[out] compatibleDependencies The dependencies found so far by calls to this function that are compatible with
 *			the targets for building the composition.
 * @param[out] incompatibleDependencies The dependencies that are incompatible with the targets for building the
 *			composition.
 */
void VuoCompiler::getDependenciesRecursively(const string &dependency,
											 set<string> &compatibleDependencies, set<string> &incompatibleDependencies)
{
	map<string, int> dependencies = getDependenciesRecursivelyWithCache(dependency, vector<string>());

	for (map<string, int>::iterator i = dependencies.begin(); i != dependencies.end(); ++i)
	{
		if (i->second == 0)
			compatibleDependencies.insert(i->first);
		else
			incompatibleDependencies.insert(i->first);
	}
}

/**
 * Helper for the other getDependenciesRecursively() function.
 *
 * Returns a structure of dependencies visited, including @a dependency, where:
 *    - 0 = compatible
 *    - 1 = incompatible
 *    - 2 = compatibility not yet known
 *
 * Adds the dependencies visited to the cache (compatibleDependenciesCache and incompatibleDependenciesCache).
 */
map<string, int> VuoCompiler::getDependenciesRecursivelyWithCache(const string &dependency, const vector<string> &ancestorsVisited)
{
	__block map<string, int> dependenciesForSelf;

	// Check if already visited (circular dependency).
	vector<string>::const_iterator av = find(ancestorsVisited.begin(), ancestorsVisited.end(), dependency);
	if (av != ancestorsVisited.end())
	{
		dependenciesForSelf[dependency] = 2;
		return dependenciesForSelf;
	}

	// Check if already cached.
	__block bool isCached = false;
	dispatch_sync(dependenciesCacheQueue, ^{
					  map<string, set<string> >::iterator cdIter = compatibleDependenciesCache.find(dependency);
					  if (cdIter != compatibleDependenciesCache.end())
					  {
						  isCached = true;
						  for (set<string>::iterator i = cdIter->second.begin(); i != cdIter->second.end(); ++i)
							  dependenciesForSelf[*i] = 0;
					  }

					  map<string, set<string> >::iterator icdIter = incompatibleDependenciesCache.find(dependency);
					  if (icdIter != incompatibleDependenciesCache.end())
					  {
						  isCached = true;
						  for (set<string>::iterator i = icdIter->second.begin(); i != icdIter->second.end(); ++i)
							  dependenciesForSelf[*i] = 0;
					  }
				  });
	if (isCached)
		return dependenciesForSelf;

	// If the composition was compiled with a different VuoCompiler instance, then node classes
	// that were generated at compile time need to be re-generated for this VuoCompiler instance.
	VuoCompilerNodeClass *nodeClass = getNodeClass(dependency);

	// See if the dependency is a node class, type, or library module, and therefore may have its
	// own dependencies.
	VuoCompilerModule *module = nodeClass ? nodeClass : getModule(dependency);

	bool isCompatible = true;
	if (module)
	{
		// Determine if the dependency is compatible with the targets.
		VuoCompilerTargetSet compositionTargets;
		compositionTargets.restrictToCurrentOperatingSystemVersion();
		isCompatible = module->getCompatibleTargets().isCompatibleWithAllOf(compositionTargets);

		// Add the dependencies of the dependency.
		vector<string> ancestorsAndSelfVisited = ancestorsVisited;
		ancestorsAndSelfVisited.push_back(dependency);
		set<string> children = module->getDependencies();
		for (set<string>::iterator i = children.begin(); i != children.end(); ++i)
		{
			string child = *i;

			map<string, int> dependenciesForChild = getDependenciesRecursivelyWithCache(child, ancestorsAndSelfVisited);
			dependenciesForSelf.insert(dependenciesForChild.begin(), dependenciesForChild.end());

			for (map<string, int>::iterator j = dependenciesForChild.begin(); j != dependenciesForChild.end(); ++j)
				if (j->second == 1)
					isCompatible = false;
		}
	}

	dependenciesForSelf[dependency] = isCompatible ? 0 : 1;

	set<string> compatibleDependenciesForSelf;
	set<string> incompatibleDependenciesForSelf;
	for (map<string, int>::iterator i = dependenciesForSelf.begin(); i != dependenciesForSelf.end(); ++i)
	{
		if (i->second == 0 || i->second == 2)
			compatibleDependenciesForSelf.insert(i->first);
		else if (i->second == 1)
			incompatibleDependenciesForSelf.insert(i->first);
	}

	dispatch_sync(dependenciesCacheQueue, ^{
					  // Add this dependency to the cache.
					  compatibleDependenciesCache[dependency].insert( compatibleDependenciesForSelf.begin(), compatibleDependenciesForSelf.end() );
					  incompatibleDependenciesCache[dependency].insert( incompatibleDependenciesForSelf.begin(), incompatibleDependenciesForSelf.end() );

					  // Update other dependencies in the cache that skipped this dependency because it wasn't fully visited yet.
					  for (map<string, int>::const_iterator i = dependenciesForSelf.begin(); i != dependenciesForSelf.end(); ++i)
					  {
						  string child = i->first;

						  if (compatibleDependenciesCache[child].find(dependency) != compatibleDependenciesCache[child].end())
						  {
							  if (! isCompatible)
								  compatibleDependenciesCache[child].erase(dependency);

							  compatibleDependenciesCache[child].insert( compatibleDependenciesForSelf.begin(), compatibleDependenciesForSelf.end() );
							  incompatibleDependenciesCache[child].insert( incompatibleDependenciesForSelf.begin(), incompatibleDependenciesForSelf.end() );
						  }
					  }
				  });

	return dependenciesForSelf;
}

/**
 * From a list of names of dependencies, gets the modules, library paths, and frameworks
 * to be passed to the linker.
 */
void VuoCompiler::getLinkerInputs(const set<string> &dependencies, Optimization optimization,
								  set<Module *> &modules, set<string> &libraries, set<string> &frameworks)
{
	set<string> allCachedResources;
	set<string> allCachedResourceDylibs;
	bool shouldUseCachedResources = optimization == Optimization_FastBuild || optimization == Optimization_FastBuildExistingCache;
	if (shouldUseCachedResources)
	{
		getCachedResources(optimization == Optimization_FastBuildExistingCache);
		for (int i = 0; i < NUM_CACHES; ++i)
		{
			allCachedResources.insert(cachedResources[i].begin(), cachedResources[i].end());
			allCachedResourceDylibs.insert(cachedResourceDylib[i]);
		}
	}

	// Use separate linkers for custom versus system search paths to control the order in which paths are searched.
	// Linker::addPaths() adds paths to the end, but Linker::addSystemPaths() adds them to the beginning.
	__block Linker *linker;
	__block Linker *systemLinker;
	vector<string> librarySearchPaths = combinedEnvironment.getLibrarySearchPaths();
	dispatch_sync(llvmQueue, ^{
					  linker = new Linker("", "", getGlobalContext());
					  linker->addPaths(librarySearchPaths);
					  systemLinker = new Linker("", "", getGlobalContext());
					  systemLinker->addSystemPaths();
				  });

	for (set<string>::iterator i = dependencies.begin(); i != dependencies.end(); ++i)
	{
		string dependency = *i;

		if (shouldUseCachedResources && allCachedResources.find(dependency) != allCachedResources.end())
			libraries.insert(allCachedResourceDylibs.begin(), allCachedResourceDylibs.end());
		else
		{
			VuoCompilerModule *module = getModule(dependency);
			if (module)
				modules.insert(module->getModule());
			else
			{
				if (VuoStringUtilities::endsWith(dependency, ".framework"))
					frameworks.insert(dependency);
				else
				{
					__block sys::Path dependencyPath;
					dispatch_sync(llvmQueue, ^{
									  dependencyPath = linker->FindLib(dependency);
								  });
					if (dependencyPath.isEmpty())
						dispatch_sync(llvmQueue, ^{
										  dependencyPath = systemLinker->FindLib(dependency);
									  });
					if (! dependencyPath.isEmpty())
						libraries.insert(dependencyPath.str());
					else
						VUserLog("Warning: Could not locate dependency '%s'.", dependency.c_str());
				}
			}
		}
	}

	dispatch_sync(llvmQueue, ^{
					  delete linker;
					  delete systemLinker;
				  });
}

/**
 * Initializes cachedResourceDylibs and cachedResources (if they haven't been already), allowing
 * them to be used when linking compositions.
 *
 * This function creates (or references, if it already exists and is up to date) a dynamic library
 * that contains:
 *   - all node classes, types, and library modules in the shared environment, except those that
 *     are premium or incompatible with the current operating system
 *   - their dependencies
 *   - the core dependencies needed by every composition
 *
 * If the dynamic library can't be created, cachedResourceDylibs and cachedResources are unchanged upon return.
 *
 * @threadNoQueue{cachedResourcesQueue}
 */
void VuoCompiler::getCachedResources(bool shouldUseExistingCache)
{
	dispatch_sync(cachedResourcesQueue, ^{
					  getCachedResourcesThreadUnsafe(shouldUseExistingCache);
				  });
}

/**
 * Version of getCachedResources() that doesn't wrap its code in cachedResourcesQueue.
 *
 * @threadQueue{cachedResourcesQueue}
 */
void VuoCompiler::getCachedResourcesThreadUnsafe(bool shouldUseExistingCache)
{
	bool hasTriedAllCachedResources = true;
	for (int i = 0; i < NUM_CACHES; ++i)
		hasTriedAllCachedResources = hasTriedAllCachedResources && hasTriedCachedResources[i];
	if (hasTriedAllCachedResources)
		return;


	// Part 1: Construct the list of resources expected to be in the cache.

	Environment *env = NULL;

	set<string> expectedResources[NUM_CACHES];
	set<Module *> modules[NUM_CACHES];
	set<string> libraries[NUM_CACHES];
	set<string> frameworks[NUM_CACHES];

	if (! shouldUseExistingCache)
	{
		// Add the loaded modules, the core dependencies, and their dependencies to the list.

		env = getSharedEnvironment();
		loadModulesIfNeeded();

		map<string, VuoCompilerModule *> allModules;
		map<string, VuoCompilerNodeClass *> nodeClasses = env->getNodeClasses();
		map<string, VuoCompilerType *> types = env->getTypes();
		map<string, VuoCompilerModule *> libraryModules = env->getLibraryModules();
		allModules.insert(nodeClasses.begin(), nodeClasses.end());
		allModules.insert(types.begin(), types.end());
		allModules.insert(libraryModules.begin(), libraryModules.end());

		set<string> dependencies[NUM_CACHES];
		for (map<string, VuoCompilerModule *>::iterator j = allModules.begin(); j != allModules.end(); ++j)
		{
			string moduleKey = j->first;
			VuoCompilerModule *module = j->second;

			if (module->getPremium())
				continue;

			set<string> dependenciesToAdd;
			set<string> incompatibleDependencies;
			getDependenciesRecursively(moduleKey, dependenciesToAdd, incompatibleDependencies);

			if (incompatibleDependencies.empty())
			{
				int i = (module->isBuiltIn() ? 0 : 1);
				dependencies[i].insert(dependenciesToAdd.begin(), dependenciesToAdd.end());
				expectedResources[i].insert(moduleKey);
			}
		}

		for (int i = 1; i < NUM_CACHES; ++i)
		{
			for (int j = 0; j < i; ++j)
			{
				set<string> uniqueDependencies;
				set_difference(dependencies[i].begin(), dependencies[i].end(),
							   dependencies[j].begin(), dependencies[j].end(),
							   std::inserter(uniqueDependencies, uniqueDependencies.end()));
				dependencies[i] = uniqueDependencies;

				set<string> uniqueExpectedResources;
				set_difference(expectedResources[i].begin(), expectedResources[i].end(),
							   expectedResources[j].begin(), expectedResources[j].end(),
							   std::inserter(uniqueExpectedResources, uniqueExpectedResources.end()));
				expectedResources[i] = uniqueExpectedResources;
			}
		}

		vector<string> coreDependencies = getCoreVuoDependencies();
		dependencies[0].insert(coreDependencies.begin(), coreDependencies.end());

		for (int i = 0; i < NUM_CACHES; ++i)
		{
			for (set<string>::iterator j = dependencies[i].begin(); j != dependencies[i].end(); ++j)
			{
				string dependency = *j;
				set<string> dependencySet;
				dependencySet.insert(dependency);

				set<Module *> modulesToAdd;
				set<string> librariesToAdd;
				set<string> frameworksToAdd;
				getLinkerInputs(dependencySet, Optimization_SmallBinary, modulesToAdd, librariesToAdd, frameworksToAdd);

				modules[i].insert(modulesToAdd.begin(), modulesToAdd.end());
				libraries[i].insert(librariesToAdd.begin(), librariesToAdd.end());
				frameworks[i].insert(frameworksToAdd.begin(), frameworksToAdd.end());

				if (! modulesToAdd.empty())
					expectedResources[i].insert(dependency);
				else if (! librariesToAdd.empty())
				{
					sys::Path libraryPath(*librariesToAdd.begin());
					if (libraryPath.isArchive() || libraryPath.isBitcodeFile())
						expectedResources[i].insert(dependency);
				}
			}
		}
	}


	string cacheDir = VuoFileUtilities::getCachePath();
	string cacheFileNames[2] = { "libVuoResources.dylib", "libVuoResources-user.dylib" };
	string indexFileNames[2] = { "index.txt", "index-user.txt" };
	string cacheFilePaths[2];
	const char separator = '\n';

	for (int i = 0; i < NUM_CACHES; ++i)
	{
		if (hasTriedCachedResources[i])
		{
			cacheFilePaths[i] = cachedResourceDylib[i];
		}
		else
		{
			hasTriedCachedResources[i] = true;
			cachedResourceDylib[i].clear();
			cachedResources[i].clear();


			// Part 2: Check if the cache contains an up-to-date version of each of the expected resources.

			cacheFilePaths[i] = cacheDir + "/" + cacheFileNames[i];
			string indexFilePath = cacheDir + "/" + indexFileNames[i];
			bool isCacheUpToDate = true;

			if (! shouldUseExistingCache)
			{
				// Check if the cached files exist. If not, create them (without affecting their last modified date).
				bool cacheDirExists = VuoFileUtilities::fileExists(cacheDir);
				if (! cacheDirExists)
					VuoFileUtilities::makeDir(cacheDir);

				bool cacheFileExists = cacheDirExists && VuoFileUtilities::fileExists(cacheFilePaths[i]);
				if (! cacheFileExists)
					VuoFileUtilities::createFile(cacheFilePaths[i]);
				bool indexFileExists = cacheDirExists && VuoFileUtilities::fileExists(indexFilePath);
				if (! indexFileExists)
					VuoFileUtilities::createFile(indexFilePath);
				if (! cacheFileExists || ! indexFileExists)
					isCacheUpToDate = false;
			}

			// Lock the cached files for reading. The lock remain active until the process exits.
			VuoFileUtilities::File cacheFile = VuoFileUtilities::File(cacheDir, cacheFileNames[i]);
			cacheFile.lockForReading();

			// Check if the cached dylib file is newer than all of the loaded modules and libraries.
			if (isCacheUpToDate && ! shouldUseExistingCache)
			{
				unsigned long cacheFileLastModified = VuoFileUtilities::getFileLastModifiedInSeconds(cacheFilePaths[i]);

				set<string> searchPaths;
				if (i == 0)
				{
					vector<string> moduleSearchPaths = env->getBuiltInModuleSearchPaths();
					vector<string> librarySearchPaths = env->getBuiltInLibrarySearchPaths();
					searchPaths.insert(moduleSearchPaths.begin(), moduleSearchPaths.end());
					searchPaths.insert(librarySearchPaths.begin(), librarySearchPaths.end());
				}
				else
				{
					vector<string> moduleSearchPaths = env->getModuleSearchPaths();
					vector<string> librarySearchPaths = env->getLibrarySearchPaths();
					vector<string> excludedModuleSearchPaths = env->getBuiltInModuleSearchPaths();
					vector<string> excludedLibrarySearchPaths = env->getBuiltInLibrarySearchPaths();
					for (vector<string>::iterator j = moduleSearchPaths.begin(); j != moduleSearchPaths.end(); ++j)
						if (find(excludedModuleSearchPaths.begin(), excludedModuleSearchPaths.end(), *j) == excludedModuleSearchPaths.end())
							searchPaths.insert(*j);
					for (vector<string>::iterator j = librarySearchPaths.begin(); j != librarySearchPaths.end(); ++j)
						if (find(excludedLibrarySearchPaths.begin(), excludedLibrarySearchPaths.end(), *j) == excludedLibrarySearchPaths.end())
							searchPaths.insert(*j);
				}

				for (set<string>::iterator j = searchPaths.begin(); j != searchPaths.end() && isCacheUpToDate; ++j)
				{
					string searchPath = *j;

					/// @todo Search recursively - https://b33p.net/kosada/node/2468
					set<VuoFileUtilities::File *> files = VuoFileUtilities::findAllFilesInDirectory(searchPath);
					for (set<VuoFileUtilities::File *>::iterator j = files.begin(); j != files.end(); ++j)
					{
						string filePath = searchPath + "/" + (*j)->getRelativePath();
						unsigned long fileLastModified = VuoFileUtilities::getFileLastModifiedInSeconds(filePath);
						if (fileLastModified > cacheFileLastModified)
						{
							isCacheUpToDate = false;
							break;
						}
					}

					for (set<VuoFileUtilities::File *>::iterator j = files.begin(); j != files.end(); ++j)
						delete *j;
				}
			}

			// Check if the cached index file matches the list of loaded modules and libraries.
			vector<string> indexedResources;
			if (isCacheUpToDate)
			{
				VuoFileUtilities::File indexFile(cacheDir, indexFileNames[i]);
				string index = indexFile.getContentsAsString();
				indexedResources = VuoStringUtilities::split(index, separator);
			}

			if (isCacheUpToDate && ! shouldUseExistingCache)
			{
				if (indexedResources.size() != expectedResources[i].size())
				{
					isCacheUpToDate = false;
				}
				else
				{
					for (vector<string>::iterator j = indexedResources.begin(); j != indexedResources.end(); ++j)
					{
						if (expectedResources[i].find(*j) == expectedResources[i].end())
						{
							isCacheUpToDate = false;
							break;
						}
					}
				}
			}

			// Check if the dylib looks remotely valid.
			if (isCacheUpToDate)
				if (!VuoFileUtilities::fileContainsReadableData(cacheFilePaths[i]))
					isCacheUpToDate = false;


			// Part 3: If the cache is not up to date, (re)create it.

			try
			{
				if (isCacheUpToDate)
				{
					cachedResources[i].insert(indexedResources.begin(), indexedResources.end());
				}
				else
				{
					// Try to upgrade the file lock for writing.
					bool gotLock = cacheFile.lockForWriting(true);

					if (gotLock)
					{
						// Link the dependencies to create the cached resources dylib.
						for (int j = 0; j < i; ++j)
						{
							libraries[i].insert(cacheFilePaths[j]);
							for (set<string>::iterator k = libraries[j].begin(); k != libraries[j].end(); ++k)
								if (VuoStringUtilities::endsWith(*k, ".dylib"))
									libraries[i].insert(*k);
						}
						link(cacheFilePaths[i], modules[i], libraries[i], frameworks[i], true);

						// Write the list of dependencies to the cached index.
						vector<string> expectedResourcesVector(expectedResources[i].begin(), expectedResources[i].end());
						string index = VuoStringUtilities::join(expectedResourcesVector, separator);
						VuoFileUtilities::writeStringToFile(index, indexFilePath);

						// Downgrade the file lock back to reading.
						cacheFile.lockForReading();

						cachedResources[i].insert(expectedResources[i].begin(), expectedResources[i].end());
						isCacheUpToDate = true;
					}
				}

				if (isCacheUpToDate)
					cachedResourceDylib[i] = cacheFilePaths[i];
			}
			catch (VuoCompilerException &e)
			{
				VUserLog("Warning: Could not create the cache for the \"faster build\" optimization: %s", e.what());
			}
		}
	}
}

/**
 * Asynchronously prepares the cache that enables compositions to build faster.
 *
 * The first time a composition is built with the "faster build" optimization, it waits until the cache
 * is prepared. Preparing the cache may take several seconds. By calling this function, the cache can be
 * prepared in advance, so that there's no delay when building the first composition.
 */
void VuoCompiler::prepareForFastBuild(void)
{
	dispatch_async(cachedResourcesQueue, ^{
					   getCachedResourcesThreadUnsafe();
				   });
}

/**
 * Controls whether the VuoCompiler should load all node classes, types, and library modules from the
 * module search paths the first time a module is needed.
 */
void VuoCompiler::setLoadAllModules(bool shouldLoadAllModules)
{
	dispatch_sync(modulesToLoadQueue, ^{
					  this->shouldLoadAllModules = shouldLoadAllModules;
				  });
}

/**
 * Links the given modules, libraries, and frameworks to create an executable or dynamic library.
 *
 * @param outputPath The resulting executable or dynamic library.
 * @param modules The LLVM modules to link in.
 * @param libraries The libraries to link in. If building an executable, one of them should contain a main function.
 * @param frameworks The frameworks to link in.
 * @param isDylib If true, the output file will be a dynamic library. Otherwise, it will be an executable.
 * @param rPath The @c -rpath argument to be passed to clang. If empty, the folder containing the Vuo framework on the build system will be used.
 * @throw VuoCompilerException clang or ld failed to link the given dependencies.
 */
void VuoCompiler::link(string outputPath, const set<Module *> &modules, const set<string> &libraries, const set<string> &frameworks, bool isDylib, string rPath)
{
	// http://stackoverflow.com/questions/11657529/how-to-generate-an-executable-from-an-llvmmodule


	// Write all the modules with renamed symbols to a composite module file (since the linker can't operate on in-memory modules).
	string compositeModulePath = VuoFileUtilities::makeTmpFile("composite", "bc");
	dispatch_sync(llvmQueue, ^{
					  Module *compositeModule = new Module("composite", getGlobalContext());
					  setTargetForModule(compositeModule);
					  for (set<Module *>::const_iterator i = modules.begin(); i != modules.end(); ++i)
					  {
						  string error;
						  if (Linker::LinkModules(compositeModule, *i, Linker::PreserveSource, &error))
						  VUserLog("Error: Failed to link compositeModule: %s", error.c_str());
					  }
					  writeModuleToBitcode(compositeModule, compositeModulePath);
					  delete compositeModule;
				  });


	// llvm-3.1/llvm/tools/clang/tools/driver/driver.cpp

	llvm::sys::Path clangPath = getClangPath();

	vector<const char *> args;
	args.push_back(clangPath.c_str());

	args.push_back(compositeModulePath.c_str());

	vector<string> coreDependencies = getCoreVuoDependencies();
	for (set<string>::const_iterator i = libraries.begin(); i != libraries.end(); ++i)
	{
		string library = *i;

		for (vector<string>::iterator j = coreDependencies.begin(); j != coreDependencies.end(); ++j)
		{
			string coreDependency = *j;
			if (VuoStringUtilities::endsWith(library, "lib" + coreDependency + ".a"))
				args.push_back("-force_load");  // Load all symbols of static core dependencies, not just those used in the objects.
		}

		args.push_back(library.c_str());
	}

	// Add framework search paths
	vector<string> frameworkArguments;

	vector<string> frameworkSearchPaths = combinedEnvironment.getFrameworkSearchPaths();
	for (vector<string>::const_iterator i = frameworkSearchPaths.begin(); i != frameworkSearchPaths.end(); ++i)
	{
		string a = "-F"+*i;
		// Keep these std::strings around until after args is done being used, since the std::string::c_str() is freed when the std::string is deleted.
		frameworkArguments.push_back(a);
		args.push_back(a.c_str());
	}

	for (set<string>::const_iterator i = frameworks.begin(); i != frameworks.end(); ++i)
	{
		args.push_back("-framework");

		string frameworkName = *i;
		frameworkName = frameworkName.substr(0, frameworkName.length() - string(".framework").length());
		args.push_back(strdup(frameworkName.c_str()));
	}

	// Check for C Runtime path within Vuo.framework
	llvm::sys::Path cRuntimePath;
	llvm::sys::Path crt1Path;
	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	string vuoFrameworkContainingFolder = vuoFrameworkPath + "/..";
	if (! vuoFrameworkPath.empty())
	{
		cRuntimePath = vuoFrameworkPath + "/Modules/";
		crt1Path = cRuntimePath;
		crt1Path.appendComponent("crt1.o");
	}

	// If we have located a bundled version of crt1.o, link it in explicitly rather than relying on
	// clang's heuristic to locate a system version.
	if (!isDylib && crt1Path.canRead())
	{
		args.push_back("-nostartfiles");
		args.push_back(crt1Path.c_str());
	}

	// Linker option necessary for compatibility with our bundled version of ld64:
	args.push_back("-Xlinker");
	args.push_back("--no-demangle");

	// Avoid generating unknown load commands.
	// http://www.cocoabuilder.com/archive/xcode/308488-load-commands-in-10-7-dylib-block-install-name-tool-on-10-6.html
	args.push_back("-Xlinker");
	args.push_back("-no_function_starts");
	args.push_back("-Xlinker");
	args.push_back("-no_version_load_command");

	if (isVerbose)
		args.push_back("-v");

	if (isDylib)
		args.push_back("-dynamiclib");

	// Tell the built dylib/executable where to find Vuo.framework
	/// @todo Once we can build app bundles (https://b33p.net/kosada/node/3362), copy only the needed dynamic dependencies into the app bundle, and change the rpath accordingly
	args.push_back("-rpath");
	string rPathArg = (!rPath.empty()? rPath : vuoFrameworkContainingFolder);
	args.push_back(rPathArg.c_str());

	// Allow clang to print meaningful error messages.
	clang::DiagnosticOptions *diagOptions = new clang::DiagnosticOptions();
	clang::TextDiagnosticPrinter *diagClient = new clang::TextDiagnosticPrinter(llvm::errs(), diagOptions);
	diagClient->setPrefix(clangPath.str());
	IntrusiveRefCntPtr<clang::DiagnosticIDs> DiagID(new clang::DiagnosticIDs());
	clang::DiagnosticsEngine Diags(DiagID, diagOptions, diagClient);

	clang::driver::Driver TheDriver(args[0], "x86_64-apple-macosx10.7.0", outputPath, true, Diags);

	TheDriver.CCCIsCXX = true;  // clang++ instead of clang

	OwningPtr<clang::driver::Compilation> C(TheDriver.BuildCompilation(args));

	int Res = 0;
	const clang::driver::Command *FailingCommand = 0;
	if (C)
		Res = TheDriver.ExecuteCompilation(*C, FailingCommand);

	// Clean up composite module file.
	remove(compositeModulePath.c_str());

	if (Res != 0)
	{
		vector<string> thirdPartyNodeClasses;
		map<string, VuoCompilerNodeClass *> nodeClasses = combinedEnvironment.getNodeClasses();
		for (map<string, VuoCompilerNodeClass *>::const_iterator i = nodeClasses.begin(); i != nodeClasses.end(); ++i)
		{
			string nodeClassName = i->first;
			if (! VuoStringUtilities::beginsWith(nodeClassName, "vuo."))
				thirdPartyNodeClasses.push_back(nodeClassName);
		}

		string details = "One or more nodes in this composition can't be used by this version of Vuo. ";
		if (! thirdPartyNodeClasses.empty())
		{
			details += "Make sure you're using the latest version of all the extra Vuo nodes you've installed:\n";
			sort(thirdPartyNodeClasses.begin(), thirdPartyNodeClasses.end());
			for (vector<string>::iterator i = thirdPartyNodeClasses.begin(); i != thirdPartyNodeClasses.end(); ++i)
				details += " • " + *i + "\n";
		}
		details += "Check the Console application for messages with more information about the problem.";

		vector<VuoCompilerError> errors;
		VuoCompilerError error("Node outdated or broken", details, set<VuoNode *>(), set<VuoCable *>());
		errors.push_back(error);
		throw VuoCompilerException(errors);
	}
}

/**
 * Returns the LLVM module read from the node class, type, or library implementation at @c inputPath (a .c file).
 */
Module * VuoCompiler::readModuleFromC(string inputPath)
{
	return readModuleFromC(inputPath, vector<string>());
}

/**
 * Returns the LLVM module read from the node class, type, or library implementation at @c inputPath (a .c file).
 */
Module * VuoCompiler::readModuleFromC(string inputPath, const vector<string> &extraArgs)
{
	// llvm-3.1/llvm/tools/clang/examples/clang-interpreter/main.cpp

	vector<const char *> args;
	args.push_back(inputPath.c_str());
	args.push_back("-DVUO_COMPILER");
	args.push_back("-fblocks");

	vector<string> headerSearchPaths = combinedEnvironment.getHeaderSearchPaths();
	for (vector<string>::iterator i = headerSearchPaths.begin(); i != headerSearchPaths.end(); ++i)
	{
		args.push_back("-I");
		args.push_back(i->c_str());
	}

	if (isVerbose)
		args.push_back("-v");

	for (vector<string>::const_iterator i = extraArgs.begin(); i != extraArgs.end(); ++i)
		args.push_back(i->c_str());

	clang::DiagnosticOptions * diagOptions = new clang::DiagnosticOptions();
	IntrusiveRefCntPtr<clang::DiagnosticIDs> DiagID(new clang::DiagnosticIDs());
	clang::DiagnosticsEngine Diags(DiagID, diagOptions);

	OwningPtr<clang::CompilerInvocation> CI(new clang::CompilerInvocation);
	clang::CompilerInvocation::CreateFromArgs(*CI, &args[0], &args[0] + args.size(), Diags);

	clang::CompilerInstance Clang;
	Clang.setInvocation(CI.take());

	Clang.createDiagnostics(args.size(), &args[0]);
	if (!Clang.hasDiagnostics())
		return NULL;

	// See CompilerInvocation::GetResourcesPath -- though we're not calling it because we don't have MainAddr.
	llvm::sys::Path clangPath = getClangPath();
	llvm::sys::Path builtinHeaderSearchPath = clangPath;
	builtinHeaderSearchPath.eraseComponent();  // Remove /clang from foo/bin/clang
	builtinHeaderSearchPath.eraseComponent();  // Remove /bin   from foo/bin
	builtinHeaderSearchPath.appendComponent("lib");
	builtinHeaderSearchPath.appendComponent("clang");
	builtinHeaderSearchPath.appendComponent(CLANG_VERSION_STRING);  // foo/lib/clang/<version>
	Clang.getHeaderSearchOpts().ResourceDir = builtinHeaderSearchPath.str();

//	OwningPtr<clang::CodeGenAction> Act(new clang::EmitLLVMOnlyAction());  // @@@ return value of takeModule() is destroyed at the end of this function
	clang::CodeGenAction *Act = new clang::EmitLLVMOnlyAction();
	if (!Clang.ExecuteAction(*Act))
		return NULL;

	return Act->takeModule();
}

/**
 * Returns the LLVM module read from @a inputPath (an LLVM bitcode file).
 *
 * @threadNoQueue{llvmQueue}
 */
Module * VuoCompiler::readModuleFromBitcode(string inputPath)
{
	string dir, file, ext;
	VuoFileUtilities::splitPath(inputPath, dir, file, ext);
	VuoFileUtilities::File inputFile(dir, file + "." + ext);
	return readModuleFromBitcode(&inputFile);
}

/**
 * Returns the LLVM module read from @a inputFile (an LLVM bitcode file).
 *
 * @threadNoQueue{llvmQueue}
 *
 * @throw std::runtime_error The file couldn't be read.
 */
Module * VuoCompiler::readModuleFromBitcode(VuoFileUtilities::File *inputFile)
{
	size_t inputDataBytes;
	char *inputData = inputFile->getContentsAsRawData(inputDataBytes);

	string error;
	Module *module = readModuleFromBitcodeData(inputData, inputDataBytes, error);
	if (! module)
		VUserLog("Error: Couldn't parse module '%s': %s.", inputFile->getRelativePath().c_str(), error.c_str());

	free(inputData);

	return module;
}

/**
 * Returns the LLVM module read from @a inputData (a data buffer of size @a inputDataBytes).
 *
 * @threadNoQueue{llvmQueue}
 */
Module * VuoCompiler::readModuleFromBitcodeData(char *inputData, size_t inputDataBytes, string &error)
{
	__block Module *module;
	dispatch_sync(llvmQueue, ^{
					  StringRef inputDataAsStringRef(inputData, inputDataBytes);
					  MemoryBuffer *mb = MemoryBuffer::getMemBuffer(inputDataAsStringRef, "", false);
					  module = ParseBitcodeFile(&(*mb), getGlobalContext(), &error);
					  delete mb;
				  });
	return module;
}

/**
 * Calls the destructor for @a module, using the LLVM global context thread-safely.
 *
 * @threadNoQueue{llvmQueue}
 */
void VuoCompiler::deleteModule(Module *module)
{
	dispatch_sync(llvmQueue, ^{
					  delete module;
				  });
}

/**
 * Returns the exceptions that were encountered when loading modules (indexed by module file path),
 * and clears the list of stored exceptions.
 */
map<string, VuoCompilerException> VuoCompiler::flushErrorsLoadingModules(void)
{
	map<string, VuoCompilerException> ret = errorsLoadingModules;
	errorsLoadingModules.clear();

	return ret;
}

/**
 * Returns the set of premium module names that the compiler has attempted to load,
 * whether or not the loads were successful.
 */
set<string> VuoCompiler::getEncounteredPremiumModules()
{
	return encounteredPremiumModules;
}

/**
 * Verifies the LLVM module and writes it to @a outputPath (an LLVM bitcode file).
 *
 * Returns true if there was a problem verifying or writing the module.
 *
 * @threadQueue{llvmQueue}
 */
bool VuoCompiler::writeModuleToBitcode(Module *module, string outputPath)
{
	if (verifyModule(*module, PrintMessageAction))
	{
		VUserLog("Error: Module verification failed.");
		return true;
	}

	string err;
	raw_fd_ostream out(outputPath.c_str(), err);
	if (! err.empty())
	{
		VUserLog("Error: Couldn't open file '%s' for writing: %s", outputPath.c_str(), err.c_str());
		return true;
	}
	WriteBitcodeToFile(module, out);

	return false;
}

/**
 * Sets the target triple for @c module. If @c target is empty, uses the target triple of the host machine.
 *
 * @threadQueue{llvmQueue}
 */
void VuoCompiler::setTargetForModule(Module *module, string target)
{
/*
	string effectiveTarget = target;
	if (effectiveTarget.empty())
	{
		// llvm::sys::getDefaultTargetTriple() finds a target based on the host, but the "default" target is not necessarily the
		// same target that results from invoking command-line clang without a -target argument. That is the "effective" target.
		// For example, the "default" target could be x86_64-apple-darwin10.8.0 and the "effective" target could be x86_64-apple-macosx10.7.0.

		llvm::sys::Path clangPath = getClangPath();

		vector<const char *> args;
		args.push_back(clangPath.c_str());
		args.push_back("/bin/sh");  // Driver needs an input file (that exists) or it refuses to give you the correct effective target.

		clang::DiagnosticOptions * diagOptions = new clang::DiagnosticOptions();
		IntrusiveRefCntPtr<clang::DiagnosticIDs> DiagID(new clang::DiagnosticIDs());
		clang::DiagnosticsEngine Diags(DiagID, diagOptions);

		clang::driver::Driver TheDriver(args[0], llvm::sys::getDefaultTargetTriple(), "a.out", true, Diags);
		OwningPtr<clang::driver::Compilation> C(TheDriver.BuildCompilation(args));
		effectiveTarget = C->getDefaultToolChain().ComputeEffectiveClangTriple(C->getArgs());
	}

	module->setTargetTriple(effectiveTarget);
*/
	module->setTargetTriple("x86_64-apple-macosx10.7.0");
}

/**
 * Instantiates a node for the given node class.
 *
 * If the node class is a generic template (e.g. vuo.data.hold), then the node is instantiated with the specialized
 * version of the node class (e.g. vuo.data.hold.VuoGenericType1).
 *
 * @param nodeClass The node class from which to create the node.
 * @param title The node's title.
 * @param x The node's x-coordinate within the composition.
 * @param y The node's y-coordinate within the composition.
 */
VuoNode * VuoCompiler::createNode(VuoCompilerNodeClass *nodeClass, string title, double x, double y)
{
	VuoCompilerNodeClass *nodeClassForNode = VuoCompilerSpecializedNodeClass::getNodeClassForNode(nodeClass, this);
	return nodeClassForNode->newNode(title, x, y);
}

/**
 * Instantiates a node used during code generation to represent published input ports.
 */
VuoNode * VuoCompiler::createPublishedInputNode(vector<VuoPublishedPort *> publishedInputPorts)
{
	__block VuoNodeClass *publishedInputNodeClass;
	dispatch_sync(llvmQueue, ^{
					  publishedInputNodeClass = VuoCompilerPublishedInputNodeClass::newNodeClass(publishedInputPorts);
				  });
	if (static_cast<VuoCompilerSpecializedNodeClass *>(publishedInputNodeClass->getCompiler())->isFullySpecialized())
		combinedEnvironment.addNodeClassToCombinedEnvironment( publishedInputNodeClass->getCompiler(), &myEnvironment, getSharedEnvironment() );

	VuoNode *publishedInputNode = publishedInputNodeClass->getCompiler()->newNode();;
	reifyGenericPortTypes(publishedInputNode);
	return publishedInputNode;
}

/**
 * Instantiates a node used during code generation to represent published output ports.
 */
VuoNode * VuoCompiler::createPublishedOutputNode(vector<VuoPublishedPort *> publishedOutputPorts)
{
	__block VuoNodeClass *publishedOutputNodeClass;
	dispatch_sync(llvmQueue, ^{
					  publishedOutputNodeClass = VuoCompilerPublishedOutputNodeClass::newNodeClass(publishedOutputPorts);
				  });
	if (static_cast<VuoCompilerSpecializedNodeClass *>(publishedOutputNodeClass->getCompiler())->isFullySpecialized())
		combinedEnvironment.addNodeClassToCombinedEnvironment( publishedOutputNodeClass->getCompiler(), &myEnvironment, getSharedEnvironment() );

	VuoNode *publishedOutputNode = publishedOutputNodeClass->getCompiler()->newNode();;
	reifyGenericPortTypes(publishedOutputNode);
	return publishedOutputNode;
}

/**
 * Looks up the VuoCompilerNodeClass for the node class specified by @a id.
 *
 * The node class module is loaded or generated if it hasn't been already.
 *
 * @eg{
 *		VuoCompiler *compiler = new VuoCompiler();
 *		VuoCompilerNodeClass *nc = compiler->getNodeClass("vuo.math.add.VuoInteger");
 *		[...]
 *		delete compiler;
 * }
 */
VuoCompilerNodeClass * VuoCompiler::getNodeClass(const string &id)
{
	dispatch_sync(modulesToLoadQueue, ^{
					  modulesToLoad.insert(id);
				  });
	loadModulesIfNeeded();

	VuoCompilerNodeClass *nodeClass = combinedEnvironment.getNodeClass(id);
	if (nodeClass)
		return nodeClass;

	VuoNodeClass *baseNodeClass = VuoCompilerSpecializedNodeClass::newNodeClass(id, this, llvmQueue);
	if (baseNodeClass)
	{
		if (static_cast<VuoCompilerSpecializedNodeClass *>(baseNodeClass->getCompiler())->isFullySpecialized())
			combinedEnvironment.addNodeClassToCombinedEnvironment( baseNodeClass->getCompiler(), &myEnvironment, getSharedEnvironment() );
		return baseNodeClass->getCompiler();
	}

	return NULL;
}

/**
 * Returns a map linking a string representation of a node class's name to its VuoCompilerNodeClass instance.
 *
 * The node class modules are loaded if they haven't been already.
 */
map<string, VuoCompilerNodeClass *> VuoCompiler::getNodeClasses()
{
	loadModulesIfNeeded();

	return combinedEnvironment.getNodeClasses();
}

/**
 * Looks up the VuoCompilerType for the port type specified by @a id.
 *
 * The port type module is loaded or generated if it haven't been already.
 */
VuoCompilerType * VuoCompiler::getType(const string &id)
{
	dispatch_sync(modulesToLoadQueue, ^{
					  if (! shouldLoadAllModules)
						  modulesToLoad.insert(id);
				  });
	loadModulesIfNeeded();

	__block VuoCompilerType *type = combinedEnvironment.getType(id);

	if (! type && VuoGenericType::isGenericTypeName(id))
	{
		VuoGenericType *genericType = new VuoGenericType(id, vector<string>());
		dispatch_sync(llvmQueue, ^{
						  type = VuoCompilerGenericType::newGenericType(genericType, this);
					  });
	}

	return type;
}

/**
 * Returns a map linking a string representation of a type's id to its VuoCompilerType instance.
 *
 * The type modules are loaded if they haven't been already.
 */
map<string, VuoCompilerType *> VuoCompiler::getTypes()
{
	loadModulesIfNeeded();

	return combinedEnvironment.getTypes();
}

/**
 * Looks up the VuoNodeSet with the given @c name.
 *
 * The node class modules are loaded if they haven't been already.
 */
VuoNodeSet * VuoCompiler::getNodeSetForName(const string &name)
{
	loadModulesIfNeeded();

	return combinedEnvironment.findNodeSet(name);
}

/**
 * Looks up the VuoCompilerNodeClass, VuoCompilerType, or VuoCompilerModule specified by @a id.
 */
VuoCompilerModule * VuoCompiler::getModule(const string &id)
{
	VuoCompilerModule *module = NULL;

	VuoCompilerNodeClass *nodeClass = combinedEnvironment.getNodeClass(id);
	if (nodeClass)
		module = nodeClass;
	else
	{
		VuoCompilerType *type = combinedEnvironment.getType(id);
		if (type)
			module = type;
		else
		{
			VuoCompilerModule *libraryModule = combinedEnvironment.getLibraryModule(id);
			if (libraryModule)
				module = libraryModule;
		}
	}

	return module;
}

/**
 * Prints a list of all loaded node classes to standard output.
 *
 * The node class modules are loaded if they haven't been already.
 *
 * @param format The format for printing the node classes.
 *	- If "", prints each class name (e.g. vuo.math.count.VuoInteger), one per line.
 *	- If "path", prints the absolute path of each node class, one per line.
 *	- If "dot", prints the declaration of a node as it would appear in a .vuo (DOT format) file,
 *		with a constant value set for each data+event input port
 *		and a comment listing metadata and port types for the node class.
 */
void VuoCompiler::listNodeClasses(const string &format)
{
	loadModulesIfNeeded();

	map<string, VuoCompilerNodeClass *> nodeClasses = combinedEnvironment.getNodeClasses();
	for (map<string, VuoCompilerNodeClass *>::const_iterator i = nodeClasses.begin(); i != nodeClasses.end(); ++i)
	{
		VuoCompilerNodeClass *nodeClass = i->second;
		if (format == "")
		{
			printf("%s\n", nodeClass->getBase()->getClassName().c_str());
		}
		else if (format == "path")
		{
			// TODO
		}
		else if (format == "dot")
		{
			VuoCompilerNode *node = nodeClass->newNode()->getCompiler();

			printf("%s\n", nodeClass->getDoxygenDocumentation().c_str());
			printf("%s\n\n", node->getGraphvizDeclaration().c_str());

			delete node;
		}
	}
}

/**
 * Returns the file names of bitcode dependencies needed by every linked Vuo composition.
 */
vector<string> VuoCompiler::getCoreVuoDependencies(void)
{
	vector<string> dependencies;
	dependencies.push_back("VuoEventLoop.bc");
	dependencies.push_back("VuoHeap");
	dependencies.push_back("VuoLog.bc");
	dependencies.push_back("VuoRuntimeContext.bc");
	dependencies.push_back("VuoRuntimeHelper.bc");
	dependencies.push_back("VuoTelemetry.bc");
	dependencies.push_back("zmq");
	dependencies.push_back("gvc");
	dependencies.push_back("graph");
	dependencies.push_back("cdt");
	dependencies.push_back("pathplan");
	dependencies.push_back("xdot");
	dependencies.push_back("gvplugin_dot_layout");
	dependencies.push_back("gvplugin_core");
	dependencies.push_back("json-c");
	dependencies.push_back("objc");
	dependencies.push_back("c");
	dependencies.push_back("AppKit.framework");
#ifdef COVERAGE
	dependencies.push_back(LLVM_ROOT "/lib/libprofile_rt.dylib");
#endif
	return dependencies;
}

/**
 * Returns the file name of the main function can accompany the Vuo runtime.
 */
string VuoCompiler::getRuntimeMainDependency(void)
{
	return "VuoRuntimeMain.bc";
}

/**
 * Returns the file name of the Vuo runtime.
 */
string VuoCompiler::getRuntimeDependency(void)
{
	return "VuoRuntime.bc";
}

/**
 * Returns the name of the library module that launches an application in the composition process.
 */
string VuoCompiler::getApplicationDependency(void)
{
	return "VuoWindow";
}

/**
 * Returns the path to the Clang binary.
 */
llvm::sys::Path VuoCompiler::getClangPath(void)
{
	return clangPath;
}

/**
 * Returns the name of the node class that would be located at @c path.
 */
string VuoCompiler::getModuleNameForPath(string path)
{
	string dir, file, extension;
	VuoFileUtilities::splitPath(path, dir, file, extension);
	return file;
}

/**
 * Adds a module search path (for node classes, types, and libraries) to use when linking a composition.
 */
void VuoCompiler::addModuleSearchPath(string path)
{
	myEnvironment.addModuleSearchPath(path);
	addLibrarySearchPath(path);
}

/**
 * Adds a header search path to use when compiling a node class.
 */
void VuoCompiler::addHeaderSearchPath(const string &path)
{
	myEnvironment.addHeaderSearchPath(path);
	combinedEnvironment.addHeaderSearchPath(path);
}

/**
 * Adds a library search path to use when linking a composition.
 */
void VuoCompiler::addLibrarySearchPath(const string &path)
{
	myEnvironment.addLibrarySearchPath(path);
	combinedEnvironment.addLibrarySearchPath(path);
}

/**
 * Adds a Mac OS X framework search path to use when linking a composition.
 */
void VuoCompiler::addFrameworkSearchPath(const string &path)
{
	myEnvironment.addFrameworkSearchPath(path);
	combinedEnvironment.addFrameworkSearchPath(path);
}

/**
 * Sets the telemetry option to use when compiling a composition. Valid values are "on" and "console".
 */
void VuoCompiler::setTelemetry(const string &telemetry)
{
	this->telemetry = telemetry;
}

/**
 * Sets the target triple to use when compiling or linking.
 */
void VuoCompiler::setTarget(const string &target)
{
	this->target = target;
}

/**
 * Sets the verbosity to use when compiling or linking. If true, prints some debug info and passes the `-v` option to Clang.
 */
void VuoCompiler::setVerbose(bool isVerbose)
{
	this->isVerbose = isVerbose;
}

/**
 * Sets the path to the clang binary.
 */
void VuoCompiler::setClangPath(const string &clangPath)
{
	this->clangPath = llvm::sys::Path(StringRef(clangPath));
}

/**
 * Returns the path to the VuoCompositionLoader executable.
 */
string VuoCompiler::getCompositionLoaderPath(void)
{
	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	return (vuoFrameworkPath.empty() ?
				VUO_ROOT "/runtime/VuoCompositionLoader" :
				vuoFrameworkPath + "/Helpers/VuoCompositionLoader.app/Contents/MacOS/VuoCompositionLoader");
}

/**
 * Returns the path to the VuoCompositionStub dynamic library.
 */
string VuoCompiler::getCompositionStubPath(void)
{
	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	return (vuoFrameworkPath.empty() ?
				VUO_ROOT "/base/VuoCompositionStub.dylib" :
				vuoFrameworkPath + "/Modules/VuoCompositionStub.dylib");
}

/**
 * Returns the path to the Modules folder inside the compiler's cache.
 */
string VuoCompiler::getCachedModulesPath(void)
{
	return VuoFileUtilities::getCachePath() + "/Modules";
}

/**
 * Prints info about this compiler, for debugging.
 */
void VuoCompiler::print(void)
{
	fprintf(stderr, "Module (node class, type, library) search paths:\n");
	vector<string> moduleSearchPaths = combinedEnvironment.getModuleSearchPaths();
	for (vector<string>::iterator i = moduleSearchPaths.begin(); i != moduleSearchPaths.end(); ++i)
		fprintf(stderr, " %s\n", (*i).c_str());
	fprintf(stderr, "Header search paths:\n");
	vector<string> headerSearchPaths = combinedEnvironment.getHeaderSearchPaths();
	for (vector<string>::iterator i = headerSearchPaths.begin(); i != headerSearchPaths.end(); ++i)
		fprintf(stderr, " %s\n", (*i).c_str());
	fprintf(stderr, "Other library search paths:\n");
	vector<string> librarySearchPaths = combinedEnvironment.getLibrarySearchPaths();
	for (vector<string>::iterator i = librarySearchPaths.begin(); i != librarySearchPaths.end(); ++i)
		fprintf(stderr, " %s\n", (*i).c_str());
	fprintf(stderr, "Other framework search paths:\n");
	vector<string> frameworkSearchPaths = combinedEnvironment.getFrameworkSearchPaths();
	for (vector<string>::iterator i = frameworkSearchPaths.begin(); i != frameworkSearchPaths.end(); ++i)
		fprintf(stderr, " %s\n", (*i).c_str());
	fprintf(stderr, "Framework path:\n");
	if (! VuoFileUtilities::getVuoFrameworkPath().empty())
		fprintf(stderr, " %s\n", VuoFileUtilities::getVuoFrameworkPath().c_str());
	fprintf(stderr, "Clang path:\n");
	if (! getClangPath().str().empty())
		fprintf(stderr, " %s\n", getClangPath().c_str());
}

/**
 * Creates a runner object that can run the composition in file @a compositionFilePath in a new process.
 *
 * @throw VuoCompilerException The composition is invalid.
 */
VuoRunner * VuoCompiler::newSeparateProcessRunnerFromCompositionFile(string compositionFilePath)
{
	VuoCompiler compiler;
	string directory, file, extension;
	VuoFileUtilities::splitPath(compositionFilePath, directory, file, extension);
	string compiledCompositionPath = VuoFileUtilities::makeTmpFile(file, "bc");
	string linkedCompositionPath = VuoFileUtilities::makeTmpFile(file + "-linked", "");
	compiler.compileComposition(compositionFilePath, compiledCompositionPath, true, false);
	compiler.linkCompositionToCreateExecutable(compiledCompositionPath, linkedCompositionPath, Optimization_FastBuild);
	remove(compiledCompositionPath.c_str());
	return VuoRunner::newSeparateProcessRunnerFromExecutable(linkedCompositionPath, directory, false, true);
}

/**
 * Creates a runner object that can run the composition in string @a composition in a new process.
 *
 * @param composition A serialized composition.
 * @param workingDirectory The directory used by nodes in the composition to resolve relative paths.
 * @throw VuoCompilerException The composition is invalid.
 */
VuoRunner * VuoCompiler::newSeparateProcessRunnerFromCompositionString(string composition, string workingDirectory)
{
	VuoCompiler compiler;
	string compiledCompositionPath = VuoFileUtilities::makeTmpFile("VuoRunnerComposition", "bc");
	string linkedCompositionPath = VuoFileUtilities::makeTmpFile("VuoRunnerComposition-linked", "");
	compiler.compileCompositionString(composition, compiledCompositionPath, true, false);
	compiler.linkCompositionToCreateExecutable(compiledCompositionPath, linkedCompositionPath, Optimization_FastBuild);
	remove(compiledCompositionPath.c_str());
	return VuoRunner::newSeparateProcessRunnerFromExecutable(linkedCompositionPath, workingDirectory, false, true);
}

/**
 * Creates a runner object that can run the composition in file @a compositionFilePath in this process.
 *
 * @throw VuoCompilerException The composition is invalid.
 */
VuoRunner * VuoCompiler::newCurrentProcessRunnerFromCompositionFile(string compositionFilePath)
{
	VuoCompiler compiler;
	string directory, file, extension;
	VuoFileUtilities::splitPath(compositionFilePath, directory, file, extension);
	string compiledCompositionPath = VuoFileUtilities::makeTmpFile(file, "bc");
	compiler.compileComposition(compositionFilePath, compiledCompositionPath, true, false);
	string linkedCompositionPath = VuoFileUtilities::makeTmpFile(file, "dylib");
	compiler.linkCompositionToCreateDynamicLibrary(compiledCompositionPath, linkedCompositionPath, Optimization_FastBuild);
	remove(compiledCompositionPath.c_str());
	return VuoRunner::newCurrentProcessRunnerFromDynamicLibrary(linkedCompositionPath, directory, true);
}

/**
 * Creates a runner object that can run the composition in string @a composition in this process.
 *
 * @param composition A serialized composition.
 * @param workingDirectory The directory used by nodes in the composition to resolve relative paths.
 * @throw VuoCompilerException The composition is invalid.
 */
VuoRunner * VuoCompiler::newCurrentProcessRunnerFromCompositionString(string composition, string workingDirectory)
{
	VuoCompiler compiler;
	string compiledCompositionPath = VuoFileUtilities::makeTmpFile("VuoRunnerComposition", "bc");
	compiler.compileCompositionString(composition, compiledCompositionPath, true, false);
	string linkedCompositionPath = VuoFileUtilities::makeTmpFile("VuoRunnerComposition", "dylib");
	compiler.linkCompositionToCreateDynamicLibrary(compiledCompositionPath, linkedCompositionPath, Optimization_FastBuild);
	remove(compiledCompositionPath.c_str());
	return VuoRunner::newCurrentProcessRunnerFromDynamicLibrary(linkedCompositionPath, workingDirectory, true);
}
